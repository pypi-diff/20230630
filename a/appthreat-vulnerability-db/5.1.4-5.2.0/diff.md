# Comparing `tmp/appthreat-vulnerability-db-5.1.4.tar.gz` & `tmp/appthreat-vulnerability-db-5.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "appthreat-vulnerability-db-5.1.4.tar", last modified: Mon May 15 20:08:40 2023, max compression
+gzip compressed data, was "appthreat-vulnerability-db-5.2.0.tar", last modified: Fri Jun 30 18:52:49 2023, max compression
```

## Comparing `appthreat-vulnerability-db-5.1.4.tar` & `appthreat-vulnerability-db-5.2.0.tar`

### file list

```diff
@@ -1,34 +1,34 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     3168 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     2209 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     3168 2023-05-15 20:08:40.000000 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)      629 2023-05-15 20:08:40.000000 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-15 20:08:40.000000 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       37 2023-05-15 20:08:40.000000 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (123)       89 2023-05-15 20:08:40.000000 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)        9 2023-05-15 20:08:40.000000 appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     1434 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/test/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5827 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/test/test_db.py
--rw-r--r--   0 runner    (1001) docker     (123)     3412 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/test/test_npm.py
--rw-r--r--   0 runner    (1001) docker     (123)    13949 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/test/test_source.py
--rw-r--r--   0 runner    (1001) docker     (123)     1116 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/test/test_storage.py
--rw-r--r--   0 runner    (1001) docker     (123)    25482 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/test/test_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/vdb/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7218 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/cli.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-15 20:08:40.251517 appthreat-vulnerability-db-5.1.4/vdb/lib/
--rw-r--r--   0 runner    (1001) docker     (123)    16533 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    39414 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/aqua.py
--rw-r--r--   0 runner    (1001) docker     (123)     5712 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/config.py
--rw-r--r--   0 runner    (1001) docker     (123)     9709 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/db.py
--rwxr-xr-x   0 runner    (1001) docker     (123)    10714 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/gha.py
--rw-r--r--   0 runner    (1001) docker     (123)    10325 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/npm.py
--rw-r--r--   0 runner    (1001) docker     (123)     8479 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/nvd.py
--rw-r--r--   0 runner    (1001) docker     (123)    12932 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/osv.py
--rw-r--r--   0 runner    (1001) docker     (123)     4159 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/storage.py
--rw-r--r--   0 runner    (1001) docker     (123)    34933 2023-05-15 20:08:24.000000 appthreat-vulnerability-db-5.1.4/vdb/lib/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:49.376959 appthreat-vulnerability-db-5.2.0/
+-rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     3207 2023-06-30 18:52:49.376959 appthreat-vulnerability-db-5.2.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2209 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:49.368958 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     3207 2023-06-30 18:52:49.000000 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)      635 2023-06-30 18:52:49.000000 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-30 18:52:49.000000 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       37 2023-06-30 18:52:49.000000 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      134 2023-06-30 18:52:49.000000 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        9 2023-06-30 18:52:49.000000 appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1514 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-30 18:52:49.376959 appthreat-vulnerability-db-5.2.0/setup.cfg
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:49.372959 appthreat-vulnerability-db-5.2.0/test/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/test/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5611 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/test/test_db.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3412 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/test/test_npm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13949 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/test/test_source.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1116 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/test/test_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25482 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/test/test_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:49.372959 appthreat-vulnerability-db-5.2.0/vdb/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7099 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/cli.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-30 18:52:49.376959 appthreat-vulnerability-db-5.2.0/vdb/lib/
+-rw-r--r--   0 runner    (1001) docker     (123)    15236 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39515 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/aqua.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5935 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9250 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/db.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    10693 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/gha.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10340 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/npm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8182 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/nvd.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12935 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/osv.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3702 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32344 2023-06-30 18:52:30.000000 appthreat-vulnerability-db-5.2.0/vdb/lib/utils.py
```

### Comparing `appthreat-vulnerability-db-5.1.4/LICENSE` & `appthreat-vulnerability-db-5.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `appthreat-vulnerability-db-5.1.4/PKG-INFO` & `appthreat-vulnerability-db-5.2.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 Metadata-Version: 2.1
 Name: appthreat-vulnerability-db
-Version: 5.1.4
+Version: 5.2.0
 Summary: AppThreat's vulnerability database and package search library with a built-in file based storage. OSV, CVE, GitHub, npm are the primary sources of vulnerabilities.
-Home-page: https://github.com/appthreat/vulnerability-db
-Author: Team AppThreat
-Author-email: cloud@appthreat.com
+Author-email: Team AppThreat <cloud@appthreat.com>
+License: MIT
+Project-URL: Homepage, https://github.com/appthreat/vulnerability-db
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: System Administrators
-Classifier: Topic :: Utilities
-Classifier: Topic :: Security
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Topic :: Security
+Classifier: Topic :: Utilities
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
+Provides-Extra: dev
 License-File: LICENSE
 
 # Introduction
 
 This repo is a vulnerability database and package search for sources such as Aqua Security vuln-list, OSV, NVD, GitHub, and NPM. Vulnerability data are downloaded from the sources and stored in a custom file based storage with indexes to allow offline access and quick searches.
 
 ## Vulnerability Data sources
```

### Comparing `appthreat-vulnerability-db-5.1.4/README.md` & `appthreat-vulnerability-db-5.2.0/README.md`

 * *Files identical despite different names*

### Comparing `appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/PKG-INFO` & `appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 Metadata-Version: 2.1
 Name: appthreat-vulnerability-db
-Version: 5.1.4
+Version: 5.2.0
 Summary: AppThreat's vulnerability database and package search library with a built-in file based storage. OSV, CVE, GitHub, npm are the primary sources of vulnerabilities.
-Home-page: https://github.com/appthreat/vulnerability-db
-Author: Team AppThreat
-Author-email: cloud@appthreat.com
+Author-email: Team AppThreat <cloud@appthreat.com>
+License: MIT
+Project-URL: Homepage, https://github.com/appthreat/vulnerability-db
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: System Administrators
-Classifier: Topic :: Utilities
-Classifier: Topic :: Security
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Topic :: Security
+Classifier: Topic :: Utilities
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
+Provides-Extra: dev
 License-File: LICENSE
 
 # Introduction
 
 This repo is a vulnerability database and package search for sources such as Aqua Security vuln-list, OSV, NVD, GitHub, and NPM. Vulnerability data are downloaded from the sources and stored in a custom file based storage with indexes to allow offline access and quick searches.
 
 ## Vulnerability Data sources
```

### Comparing `appthreat-vulnerability-db-5.1.4/appthreat_vulnerability_db.egg-info/SOURCES.txt` & `appthreat-vulnerability-db-5.2.0/appthreat_vulnerability_db.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 LICENSE
 README.md
-setup.py
+pyproject.toml
 appthreat_vulnerability_db.egg-info/PKG-INFO
 appthreat_vulnerability_db.egg-info/SOURCES.txt
 appthreat_vulnerability_db.egg-info/dependency_links.txt
 appthreat_vulnerability_db.egg-info/entry_points.txt
 appthreat_vulnerability_db.egg-info/requires.txt
 appthreat_vulnerability_db.egg-info/top_level.txt
 test/__init__.py
```

### Comparing `appthreat-vulnerability-db-5.1.4/test/test_db.py` & `appthreat-vulnerability-db-5.2.0/test/test_db.py`

 * *Files 6% similar despite different names*

```diff
@@ -53,15 +53,15 @@
     assert len(docs) > 0
     all_data = db.list_all(table)
     assert all_data
     for d in all_data:
         res = db.pkg_search(
             table,
             d["details"]["package"],
-            d["details"]["max_affected_version_including"],
+            d["details"]["mai"],
         )
         assert len(res)
         assert res[0].to_dict()["package_issue"]
 
 
 def test_search_fast(test_db, test_vuln_data):
     table = test_db
@@ -70,15 +70,15 @@
     docs = db.store(test_db, test_vuln_data)
     assert len(docs) > 0
     all_data = db.list_all(table)
     assert all_data
     search_list = [
         {
             "name": d["details"]["package"],
-            "version": d["details"]["max_affected_version_including"],
+            "version": d["details"]["mai"],
         }
         for d in all_data
     ]
     res = db.bulk_index_search(search_list)
     assert len(res)
 
 
@@ -92,15 +92,15 @@
     docs = db.list_all(table)
     assert len(docs) == 0
     docs = db.store(test_db, test_gha_data)
     assert len(docs) > 0
     all_data = db.list_all(table)
     assert all_data
     for d in all_data:
-        version = d["details"]["max_affected_version_including"]
+        version = d["details"]["mai"]
         if version and version != "*":
             res = db.pkg_search(
                 table,
                 d["details"]["package"],
                 version,
             )
             assert len(res)
@@ -113,15 +113,15 @@
     assert len(docs) == 0
     docs = db.store(test_db, test_gha_data)
     assert len(docs) > 0
     all_data = db.list_all(table)
     assert all_data
     for d in all_data:
         vendor, _, _, cve_type = parse_cpe(d["details"]["cpe_uri"])
-        version = d["details"]["max_affected_version_including"]
+        version = d["details"]["mai"]
         if version and version != "*":
             res = db.vendor_pkg_search(
                 table,
                 vendor,
                 d["details"]["package"],
                 version,
             )
@@ -136,18 +136,18 @@
     docs = db.store(test_db, test_gha_data)
     assert len(docs) > 0
     all_data = db.list_all(table)
     assert all_data
     tmp_list = [
         {
             "name": d["details"]["package"],
-            "version": d["details"]["max_affected_version_including"],
+            "version": d["details"]["mai"],
         }
         for d in all_data
-        if d["details"]["max_affected_version_including"] != "*"
+        if d["details"]["mai"] != "*"
     ]
     res = db.bulk_index_search(tmp_list)
     assert len(res)
 
 
 def test_index_search(test_db, test_vuln_data):
     # This slow test ensures that every data in the main database is indexed
@@ -156,15 +156,15 @@
     assert len(docs) == 0
     docs = db.store(test_db, test_vuln_data)
     assert len(docs) > 0
     all_data = db.list_all(table)
     assert all_data
     tmp_list = []
     for d in all_data[:40]:
-        version = d["details"]["max_affected_version_including"]
+        version = d["details"]["mai"]
         if version and version != "*":
             tmp_list.append({"name": d["details"]["package"], "version": version})
     res = db.bulk_index_search(tmp_list)
     assert len(res)
     for r in res:
         name_ver = r.split("|")
         fullres = db.index_search(name_ver[1], name_ver[2])
@@ -183,15 +183,15 @@
     tmp_list = []
     for d in all_data[:40]:
         vendor, _, _, cve_type = parse_cpe(d["details"]["cpe_uri"])
         tmp_list.append(
             {
                 "vendor": vendor,
                 "name": d["details"]["package"],
-                "version": d["details"]["max_affected_version_including"],
+                "version": d["details"]["mai"],
             }
         )
     res = db.bulk_index_search(tmp_list)
     assert len(res)
     for r in res:
         name_ver = r.split("|")
         fullres = db.index_search(name_ver[2], name_ver[3])
```

### Comparing `appthreat-vulnerability-db-5.1.4/test/test_npm.py` & `appthreat-vulnerability-db-5.2.0/test/test_npm.py`

 * *Files identical despite different names*

### Comparing `appthreat-vulnerability-db-5.1.4/test/test_source.py` & `appthreat-vulnerability-db-5.2.0/test/test_source.py`

 * *Files identical despite different names*

### Comparing `appthreat-vulnerability-db-5.1.4/test/test_storage.py` & `appthreat-vulnerability-db-5.2.0/test/test_storage.py`

 * *Files identical despite different names*

### Comparing `appthreat-vulnerability-db-5.1.4/test/test_utils.py` & `appthreat-vulnerability-db-5.2.0/test/test_utils.py`

 * *Files identical despite different names*

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/cli.py` & `appthreat-vulnerability-db-5.2.0/vdb/cli.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 
 import argparse
 import logging
 import os
 import re
+import shutil
 
 from tabulate import tabulate
 
-from vdb.lib import config as config
+from vdb.lib import config
 from vdb.lib import db as dbLib
 from vdb.lib.aqua import AquaSource
 from vdb.lib.gha import GitHubSource
 from vdb.lib.npm import NpmSource
 from vdb.lib.nvd import NvdSource
 from vdb.lib.osv import OSVSource
 
@@ -130,85 +131,80 @@
         "CWE",
         "Severity",
         "Score",
         "Description",
     ]
     for res in results:
         vuln_occ_dict = res.to_dict()
-        id = vuln_occ_dict.get("id")
+        vid = vuln_occ_dict.get("id")
         package_type = vuln_occ_dict.get("type")
-        if id not in added_list:
+        if vid not in added_list:
             package_issue = res.package_issue
             full_pkg = package_issue.affected_location.package
             if package_issue.affected_location.vendor:
-                full_pkg = "{}:{}".format(
-                    package_issue.affected_location.vendor,
-                    package_issue.affected_location.package,
-                )
+                full_pkg = f"{package_issue.affected_location.vendor}:{package_issue.affected_location.package}"
             if package_type and package_type not in ("*", "o", "h"):
                 full_pkg = package_type + ":" + full_pkg
             table.append(
                 [
-                    id,
+                    vid,
                     full_pkg,
                     package_issue.affected_location.version,
                     package_issue.fixed_location,
                     vuln_occ_dict.get("problem_type"),
                     vuln_occ_dict.get("severity"),
                     vuln_occ_dict.get("cvss_score"),
                     vuln_occ_dict.get("short_description"),
                 ]
             )
-            added_list.append(id)
+            added_list.append(vid)
     print(tabulate(table, headers, tablefmt="grid"))
 
 
 def main():
+    """Main function"""
     args = build_args()
     print(at_logo)
     if args.clean:
         if os.path.exists(config.data_dir):
-            try:
-                os.rmdir(config.data_dir)
-            except Exception:
-                pass
+            shutil.rmtree(config.data_dir, ignore_errors=True)
     if args.cache or args.cache_os:
         if args.only_osv:
             sources = [OSVSource()]
         elif args.only_aqua:
             sources = [AquaSource()]
         else:
             sources = [OSVSource(), GitHubSource(), NvdSource()]
         if args.cache_os:
             sources.insert(0, AquaSource())
         for s in sources:
-            LOG.info("Refreshing {}".format(s.__class__.__name__))
+            LOG.info("Refreshing %s", s.__class__.__name__)
             s.refresh()
     elif args.sync:
         for s in [GitHubSource(), NvdSource()]:
-            LOG.info("Syncing {}".format(s.__class__.__name__))
+            LOG.info("Syncing %s", s.__class__.__name__)
             s.download_recent()
     if args.sync_npm:
         for s in [NpmSource()]:
-            LOG.info("Syncing {}".format(s.__class__.__name__))
+            LOG.info("Syncing %s", s.__class__.__name__)
             s.download_recent()
     if args.sync_github:
         for s in [GitHubSource()]:
-            LOG.info("Syncing {}".format(s.__class__.__name__))
+            LOG.info("Syncing %s", s.__class__.__name__)
             s.download_recent()
     if args.search_npm:
         source = NpmSource()
         results = source.bulk_search(config.npm_app_info, [args.search_npm])
         print_results(results)
     if args.list:
         db = dbLib.get()
         results = dbLib.list_all_occurrence(db)
         print_results(results)
     elif args.search:
-        LOG.info("Vulnerability database loaded from {}".format(config.vdb_bin_file))
+        LOG.info("Vulnerability database loaded from %s", config.vdb_bin_file)
         db = dbLib.get()
         search_list = re.split(r"[,|;]", args.search)
         for pkg_info in search_list:
             pstr = re.split(r"[:=@]", pkg_info)
             if pstr:
                 if len(pstr) == 2 and dbLib.index_search(*pstr):
                     results = dbLib.pkg_search(db, *pstr)
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/__init__.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -203,46 +203,46 @@
         source_update_time,
     ):
         parts = CPE_REGEX.match(cpe_uri)
         self.cpe_uri = cpe_uri
         # Occasionally, NVD CPE value could be invalid. We need to guard against this
         if parts:
             self.package = package if package else parts.group("package")
-            self.min_affected_version_including = (
+            self.mii = (
                 min_affected_version_including
                 if min_affected_version_including
                 else parts.group("version")
             )
-            self.max_affected_version_including = (
+            self.mai = (
                 max_affected_version_including
                 if max_affected_version_including
                 else parts.group("version")
             )
         else:
             # Use split to extract the package name in case of bad CPE value
             package_workaround = ""
             if cpe_uri:
                 cpe_parts = cpe_uri.split(":")
                 if len(cpe_parts) > 4:
                     package_workaround = cpe_parts[4]
             self.package = package if package else package_workaround
-            self.min_affected_version_including = (
+            self.mii = (
                 min_affected_version_including
                 if min_affected_version_including
                 else "*"
             )
-            self.max_affected_version_including = (
+            self.mai = (
                 max_affected_version_including
                 if max_affected_version_including
                 else "*"
             )
-        self.min_affected_version_excluding = (
+        self.mie = (
             min_affected_version_excluding if min_affected_version_excluding else None
         )
-        self.max_affected_version_excluding = (
+        self.mae = (
             max_affected_version_excluding if max_affected_version_excluding else None
         )
         self.severity = Severity.from_str(severity)
         self.description = description
         self.fixed_location = fixed_location
         self.package_type = VulnerabilityDetail.get_type(cpe_uri, package_type)
         self.is_obsolete = is_obsolete
@@ -284,18 +284,18 @@
         return None
 
     @staticmethod
     def from_dict(detail):
         return VulnerabilityDetail(
             detail.get("cpe_uri"),
             detail.get("package"),
-            detail.get("min_affected_version_including"),
-            detail.get("max_affected_version_including"),
-            detail.get("min_affected_version_excluding"),
-            detail.get("max_affected_version_excluding"),
+            detail.get("mii"),
+            detail.get("mai"),
+            detail.get("mie"),
+            detail.get("mae"),
             detail.get("severity"),
             detail.get("description"),
             detail.get("fixed_location"),
             detail.get("package_type"),
             detail.get("is_obsolete"),
             detail.get("source_update_time"),
         )
@@ -304,29 +304,29 @@
 class PackageIssue(object):
     """Package issue class"""
 
     def __init__(
         self,
         affected_location,
         fixed_location,
-        min_affected_version_including=None,
-        max_affected_version_including=None,
-        min_affected_version_excluding=None,
-        max_affected_version_excluding=None,
+        mii=None,
+        mai=None,
+        mie=None,
+        mae=None,
     ):
         self.affected_location = VulnerabilityLocation.from_values(
             affected_location,
-            min_affected_version_including,
-            max_affected_version_including,
-            min_affected_version_excluding,
-            max_affected_version_excluding,
+            mii,
+            mai,
+            mie,
+            mae,
         )
         # If there is no fixed_location but there is max excluded version then consider that as the fix
-        if not fixed_location and max_affected_version_excluding:
-            self.fixed_location = max_affected_version_excluding
+        if not fixed_location and mae:
+            self.fixed_location = mae
         else:
             if fixed_location and fixed_location.startswith("cpe"):
                 # Extract the fixed version from fixed_location cpe uri
                 fixed_parts = (
                     CPE_REGEX.match(fixed_location) if fixed_location else None
                 )
                 if fixed_parts:
@@ -404,54 +404,44 @@
         self.vendor = vendor
         self.package = package
         self.version = version
 
     @staticmethod
     def from_values(
         cpe_uri,
-        min_affected_version_including=None,
-        max_affected_version_including=None,
-        min_affected_version_excluding=None,
-        max_affected_version_excluding=None,
+        mii=None,
+        mai=None,
+        mie=None,
+        mae=None,
     ):
-        if (
-            not cpe_uri
-            and not min_affected_version_including
-            and not max_affected_version_including
-            and not min_affected_version_excluding
-            and not max_affected_version_excluding
-        ):
+        if not cpe_uri and not mii and not mai and not mie and not mae:
             return None
         if cpe_uri:
             parts = CPE_REGEX.match(cpe_uri)
-            version = (
-                max_affected_version_including
-                if max_affected_version_including
-                else parts.group(3)
-            )
+            version = mai if mai else parts.group(3)
         version_left = ""
         version_right = ""
-        if min_affected_version_excluding:
-            version_left = ">" + min_affected_version_excluding
-        if min_affected_version_including and min_affected_version_including != "*":
-            version_left = ">=" + min_affected_version_including
-        if max_affected_version_excluding:
-            version_right = "<" + max_affected_version_excluding
-        if max_affected_version_including and max_affected_version_including != "*":
-            version_right = "<=" + max_affected_version_including
+        if mie:
+            version_left = ">" + mie
+        if mii and mii != "*":
+            version_left = ">=" + mii
+        if mae:
+            version_right = "<" + mae
+        if mai and mai != "*":
+            version_right = "<=" + mai
         if version_left and not version_right:
             version = version_left
             # Convert >0.0.0 to *
             if version == ">0.0.0":
                 version = "*"
         elif not version_left and version_right:
             version = version_right
         elif version_left and version_right:
-            if min_affected_version_including == max_affected_version_including:
-                version = max_affected_version_including
+            if mii == mai:
+                version = mai
             else:
                 version = "{}-{}".format(version_left, version_right)
         if parts:
             return VulnerabilityLocation(
                 cpe_uri, parts.group("vendor"), parts.group("package"), version
             )
         else:
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/aqua.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/aqua.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,18 +5,18 @@
 """
 import os
 from datetime import datetime
 from zipfile import ZipFile
 
 import httpx
 
-from vdb.lib import CustomNamedTemporaryFile
-from vdb.lib import config as config
+from vdb.lib import CustomNamedTemporaryFile, config
 from vdb.lib.nvd import NvdSource
 from vdb.lib.utils import (
+    compress_str,
     convert_score_severity,
     get_cvss3_from_vector,
     get_default_cve_data,
 )
 
 # Size of the stream to read and write to the file
 download_chunk_size = 4096
@@ -228,15 +228,15 @@
                 score=score,
                 exploitabilityScore=exploitabilityScore,
                 publishedDate=publishedDate,
                 lastModifiedDate=lastModifiedDate,
             )
             try:
                 vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                vuln.description = description
+                vuln.description = compress_str(description)
                 ret_data.append(vuln)
             except Exception:
                 pass
         return ret_data
 
     def alas_rlsa_to_vuln(self, cve_data, vendor):
         """Amazon Linux"""
@@ -306,15 +306,15 @@
                     score=score,
                     exploitabilityScore=exploitabilityScore,
                     publishedDate=publishedDate,
                     lastModifiedDate=lastModifiedDate,
                 )
                 try:
                     vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                    vuln.description = description
+                    vuln.description = compress_str(description)
                     ret_data.append(vuln)
                     done_pkgs[pkg_key] = True
                 except Exception:
                     pass
         return ret_data
 
     def ubuntu_to_vuln(self, cve_data):
@@ -416,15 +416,15 @@
                             score=score,
                             exploitabilityScore=exploitabilityScore,
                             publishedDate=publishedDate,
                             lastModifiedDate=lastModifiedDate,
                         )
                         try:
                             vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                            vuln.description = description
+                            vuln.description = compress_str(description)
                             ret_data.append(vuln)
                         except Exception:
                             pass
         return ret_data
 
     def redhat_to_vuln(self, cve_data):
         """RedHat Linux"""
@@ -524,15 +524,15 @@
                     score=score,
                     exploitabilityScore=exploitabilityScore,
                     publishedDate=publishedDate,
                     lastModifiedDate=lastModifiedDate,
                 )
                 try:
                     vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                    vuln.description = description
+                    vuln.description = compress_str(description)
                     ret_data.append(vuln)
                     done_pkgs[pkg_key] = True
                 except Exception:
                     pass
         return ret_data
 
     def arch_to_vuln(self, cve_data):
@@ -586,15 +586,15 @@
                     score=score,
                     exploitabilityScore=score,
                     publishedDate=publishedDate,
                     lastModifiedDate=lastModifiedDate,
                 )
                 try:
                     vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                    vuln.description = description
+                    vuln.description = compress_str(description)
                     ret_data.append(vuln)
                 except Exception:
                     pass
         return ret_data
 
     def suse_to_vuln(self, cve_data):
         """Suse Linux"""
@@ -669,15 +669,15 @@
                             score=score,
                             exploitabilityScore=score,
                             publishedDate=publishedDate,
                             lastModifiedDate=lastModifiedDate,
                         )
                         try:
                             vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                            vuln.description = description
+                            vuln.description = compress_str(description)
                             ret_data.append(vuln)
                             done_pkgs[pkg_key] = True
                         except Exception:
                             pass
         return ret_data
 
     def photon_to_vuln(self, cve_data):
@@ -739,15 +739,15 @@
                 score=score,
                 exploitabilityScore=score,
                 publishedDate=publishedDate,
                 lastModifiedDate=lastModifiedDate,
             )
             try:
                 vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                vuln.description = description
+                vuln.description = compress_str(description)
                 ret_data.append(vuln)
             except Exception:
                 pass
         return ret_data
 
     def debian_to_vuln(self, cve_data):
         """Debian Linux"""
@@ -867,15 +867,15 @@
                     score=score,
                     exploitabilityScore=score,
                     publishedDate=publishedDate,
                     lastModifiedDate=lastModifiedDate,
                 )
                 try:
                     vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                    vuln.description = description
+                    vuln.description = compress_str(description)
                     ret_data.append(vuln)
                 except Exception:
                     pass
         return ret_data
 
     def wolfi_to_vuln(self, cve_data):
         """Wolfi OS and Chainguard"""
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/config.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/config.py`

 * *Files 8% similar despite different names*

```diff
@@ -54,15 +54,14 @@
     "hex": "https://osv-vulnerabilities.storage.googleapis.com/Hex/all.zip",
     "packagist": "https://osv-vulnerabilities.storage.googleapis.com/Packagist/all.zip",
     "pub": "https://osv-vulnerabilities.storage.googleapis.com/Pub/all.zip",
     "uvi": "https://osv-vulnerabilities.storage.googleapis.com/UVI/all.zip",
     "github": "https://osv-vulnerabilities.storage.googleapis.com/GitHub%20Actions/all.zip",
     "android": "https://osv-vulnerabilities.storage.googleapis.com/Android/all.zip",
     "alpine": "https://osv-vulnerabilities.storage.googleapis.com/Alpine/all.zip",
-    "gsd": "https://osv-vulnerabilities.storage.googleapis.com/GSD/all.zip",
     "linux": "https://osv-vulnerabilities.storage.googleapis.com/Linux/all.zip",
     "debian": "https://osv-vulnerabilities.storage.googleapis.com/Debian/all.zip",
     "oss-fuzz": "https://osv-vulnerabilities.storage.googleapis.com/OSS-Fuzz/all.zip",
 }
 
 aquasec_vuln_list_url = (
     "https://github.com/appthreat/vuln-list/archive/refs/heads/main.zip"
@@ -76,7 +75,14 @@
 # Placeholder fix version to use to indicate max versions
 placeholder_fix_version = "99.99.9"
 
 # Placeholder exclude version to use to indicate non-vulnerability
 # This is highly important for debian where a specific distro may be non-vulnerable
 # While CPEs are the correct method of representing the exclusion, this version hack is aimed to be a short workaround
 placeholder_exclude_version = "88.88.8"
+
+# How many CVEs should be packed and written to the db file as a unit
+# A large value here requires a larger max_buffer_size. Else could lead to msgpack.exceptions.BufferFull exceptions during read
+batch_write_size = 20
+
+# Limits size of unpacked data
+max_buffer_size = 200 * 1024 * 1024  # 200 MiB
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/db.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/db.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,10 @@
 from collections import defaultdict
 
-from vdb.lib import config as config
-from vdb.lib import storage as storage
+from vdb.lib import config, storage
 from vdb.lib.utils import convert_to_occurrence, parse_cpe, version_compare
 
 index_data = None
 vendor_index_data = None
 pos_index_data = None
 
 
@@ -21,20 +20,20 @@
     pos_idx = defaultdict(list)
     for dp in index_pos_list:
         store_pos = dp.get("store_pos")
         store_end_pos = dp.get("store_end_pos")
         for d in dp.get("index_list"):
             cve_id = d.get("id")
             min_version = d.get(
-                "min_affected_version_excluding",
-                d.get("min_affected_version_including"),
+                "mie",
+                d.get("mii"),
             )
             max_version = d.get(
-                "max_affected_version_excluding",
-                d.get("max_affected_version_including"),
+                "mae",
+                d.get("mai"),
             )
             if not min_version:
                 min_version = "0"
             if not max_version:
                 max_version = "*"
             ver_range_str = f"{min_version}-{max_version}|{cve_id}"
             idx[d["name"]].append(ver_range_str)
@@ -121,36 +120,28 @@
     max_affected_version_excluding = None
     cpe_uri = ""
     if isinstance(data, dict):
         if not data.get("details"):
             return False
         cpe_uri = data["details"].get("cpe_uri")
         package = data["details"].get("package")
-        min_affected_version_including = data["details"].get(
-            "min_affected_version_including", "0"
-        )
-        min_affected_version_excluding = data["details"].get(
-            "min_affected_version_excluding", None
-        )
-        max_affected_version_including = data["details"].get(
-            "max_affected_version_including", "*"
-        )
-        max_affected_version_excluding = data["details"].get(
-            "max_affected_version_excluding", None
-        )
+        min_affected_version_including = data["details"].get("mii", "0")
+        min_affected_version_excluding = data["details"].get("mie", None)
+        max_affected_version_including = data["details"].get("mai", "*")
+        max_affected_version_excluding = data["details"].get("mae", None)
     else:
         cpe_uri = data.details.cpe_uri
         package = data.details.package
-        min_affected_version_including = data.details.min_affected_version_including
-        max_affected_version_including = data.details.max_affected_version_including
-        min_affected_version_excluding = data.details.min_affected_version_excluding
-        max_affected_version_excluding = data.details.max_affected_version_excluding
+        min_affected_version_including = data.details.mii
+        max_affected_version_including = data.details.mai
+        min_affected_version_excluding = data.details.mie
+        max_affected_version_excluding = data.details.mae
     if not cpe_uri:
         return False
-    vendor, _, _, cve_type = parse_cpe(cpe_uri)
+    vendor, _, _, _ = parse_cpe(cpe_uri)
     for match in match_list:
         name_ver = match.split("|")
         # Search by name and version
         if len(name_ver) == 2:
             # Check if we have a hit
             if name_ver[0] == package and version_compare(
                 name_ver[1],
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/gha.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/gha.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,25 +19,25 @@
 except ImportError:
     import json
 
     ORJSON_AVAILABLE = False
 
 import httpx
 
-from vdb.lib import config as config
+from vdb.lib import config
 from vdb.lib.nvd import NvdSource
-from vdb.lib.utils import get_default_cve_data
+from vdb.lib.utils import compress_str, get_default_cve_data
 
 logging.basicConfig(
     level=logging.INFO, format="%(levelname)s [%(asctime)s] %(message)s"
 )
 LOG = logging.getLogger(__name__)
 
 api_token = os.environ.get("GITHUB_TOKEN")
-headers = {"Authorization": "token %s" % api_token}
+headers = {"Authorization": f"token {api_token}"}
 
 json_lib = orjson if ORJSON_AVAILABLE else json
 
 
 def get_query(type="recent"):
     """"""
     extra_args = ""
@@ -115,17 +115,15 @@
         if data and local_store:
             self.store(data)
         return data
 
     def fetch(self, type):
         """Private method to fetch the advisory data via GraphQL api"""
         LOG.debug(
-            "Download GitHub advisory from {} with cursor {}".format(
-                config.gha_url, type
-            )
+            "Download GitHub advisory from %s with cursor %s", config.gha_url, type
         )
         client = httpx.Client(http2=True, follow_redirects=True, timeout=180)
         r = client.post(url=config.gha_url, json=get_query(type=type), headers=headers)
         json_data = r.json()
         return self.convert(json_data)
 
     def get_version_range(self, version_str):
@@ -267,12 +265,12 @@
                     exploitabilityScore=exploitabilityScore,
                     publishedDate=cve["publishedAt"],
                     lastModifiedDate=cve["updatedAt"],
                 )
                 try:
                     tdata_json = json_lib.loads(tdata)
                     vuln = NvdSource.convert_vuln(tdata_json)
-                    vuln.description = description
+                    vuln.description = compress_str(description)
                     ret_data.append(vuln)
                 except Exception as e:
                     LOG.debug(e)
         return ret_data, page_info
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/npm.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/npm.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,17 +12,18 @@
 except ImportError:
     import json
 
     ORJSON_AVAILABLE = False
 
 import httpx
 
-from vdb.lib import config as config
+from vdb.lib import config
 from vdb.lib.nvd import NvdSource
 from vdb.lib.utils import (
+    compress_str,
     convert_md_references,
     convert_to_occurrence,
     fix_text,
     get_default_cve_data,
     serialize_vuln_list,
 )
 
@@ -68,15 +69,15 @@
             dependencies[key] = {"version": version}
         payload["requires"] = requires
         payload["dependencies"] = dependencies
         return convert_to_occurrence(serialize_vuln_list(self.fetch(payload)))
 
     def fetch(self, payload):
         client = httpx.Client(http2=True, follow_redirects=True, timeout=180)
-        LOG.debug("Fetch npm advisory from {}".format(config.npm_audit_url))
+        LOG.debug("Fetch npm advisory from %s", config.npm_audit_url)
         r = client.post(url=config.npm_audit_url, json=payload)
         json_data = r.json()
         return self.convert(json_data)
 
     def download_recent(self, local_store=True):
         """Method which downloads the recent CVE"""
         client = httpx.Client(http2=True, follow_redirects=True, timeout=180)
@@ -263,13 +264,13 @@
                     score=score,
                     exploitabilityScore=exploitabilityScore,
                     publishedDate=publishedDate,
                     lastModifiedDate=lastModifiedDate,
                 )
                 try:
                     vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                    vuln.description = description
+                    vuln.description = compress_str(description)
                     ret_data.append(vuln)
                 except Exception as e:
                     LOG.debug(e)
                 vr = vr + 1
         return ret_data
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/nvd.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/nvd.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,16 +15,16 @@
 
 from vdb.lib import (
     CustomNamedTemporaryFile,
     CvssV3,
     Vulnerability,
     VulnerabilityDetail,
     VulnerabilitySource,
+    config,
 )
-from vdb.lib import config as config
 from vdb.lib import db as dbLib
 
 logging.basicConfig(
     level=logging.INFO, format="%(levelname)s [%(asctime)s] %(message)s"
 )
 LOG = logging.getLogger(__name__)
 
@@ -72,32 +72,33 @@
         if local_store:
             self.store(data)
         return data
 
     def fetch(self, year):
         """Private Method which downloads the given CVE gzip from NVD"""
         url = config.nvd_url % dict(year=year)
-        LOG.debug("Download NVD CVE from {}".format(url))
+        LOG.debug("Download NVD CVE from %s", url)
         with CustomNamedTemporaryFile() as tf:
             try:
                 with httpx.stream("GET", url, follow_redirects=True, timeout=180) as r:
                     for chunk in r.iter_bytes(chunk_size=download_chunk_size):
                         tf.write(chunk)
                     tf.flush()
             except Exception:
-                logging.warning(f"Exception while downloading NVD feed from {url}")
+                logging.warning("Exception while downloading NVD feed from %s", url)
                 return None
             with gzip.open(tf.name, "rb") as gzipjf:
                 try:
                     cve_data = gzipjf.read()
                     json_data = json_lib.loads(cve_data)
                     return self.convert(json_data)
                 except Exception:
                     logging.warning(
-                        f"Exception while parsing NVD CVE feed for {year}. Please try after some time"
+                        "Exception while parsing NVD CVE feed for %s. Please try after some time",
+                        year,
                     )
                     return None
 
     def convert(self, cve_data):
         """Convert cve data to Vulnerability"""
         items = cve_data.get("CVE_Items")
         data = []
@@ -199,26 +200,18 @@
             fix_cpe_uri = None
             for cpe in cpe_list:
                 detail = {}
                 if not cpe.get("cpe23Uri"):
                     continue
                 if cpe["vulnerable"] and cpe.get("cpe23Uri"):
                     detail["cpe_uri"] = cpe["cpe23Uri"]
-                    detail["min_affected_version_including"] = cpe.get(
-                        "versionStartIncluding"
-                    )
-                    detail["min_affected_version_excluding"] = cpe.get(
-                        "versionStartExcluding"
-                    )
-                    detail["max_affected_version_including"] = cpe.get(
-                        "versionEndIncluding"
-                    )
-                    detail["max_affected_version_excluding"] = cpe.get(
-                        "versionEndExcluding"
-                    )
+                    detail["mii"] = cpe.get("versionStartIncluding")
+                    detail["mie"] = cpe.get("versionStartExcluding")
+                    detail["mai"] = cpe.get("versionEndIncluding")
+                    detail["mae"] = cpe.get("versionEndExcluding")
                     detail["source_update_time"] = vuln["lastModifiedDate"]
                     cpe_details_list.append(detail)
                 else:  # cpe is not vulnerable
                     if node["operator"] == "OR":
                         fix_cpe_uri = cpe["cpe23Uri"]
             # Add fix version details
             for det in cpe_details_list:
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/osv.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/osv.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,18 +3,18 @@
 
 This module fetches the vulnerability data from osv.dev and stores them in NVD CVE 1.1 json format.
 """
 from zipfile import ZipFile
 
 import httpx
 
-from vdb.lib import CustomNamedTemporaryFile
-from vdb.lib import config as config
+from vdb.lib import CustomNamedTemporaryFile, config
 from vdb.lib.nvd import NvdSource
 from vdb.lib.utils import (
+    compress_str,
     convert_score_severity,
     get_cvss3_from_vector,
     get_default_cve_data,
     parse_purl,
 )
 
 # Size of the stream to read and write to the file
@@ -284,12 +284,12 @@
                                 score=score,
                                 exploitabilityScore=exploitabilityScore,
                                 publishedDate=cve_data.get("published"),
                                 lastModifiedDate=cve_data.get("modified"),
                             )
                             try:
                                 vuln = NvdSource.convert_vuln(json_lib.loads(tdata))
-                                vuln.description = description
+                                vuln.description = compress_str(description)
                                 ret_data.append(vuln)
                             except Exception:
                                 pass
         return ret_data
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/storage.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/storage.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,49 +1,42 @@
 import os.path
 
 import msgpack
 
-from vdb.lib import config as config
+from vdb.lib import config
 from vdb.lib.utils import chunk_list, parse_cpe, serialize_vuln_list
 
-read_size = 256
-batch_write_size = 20
-max_buffer_size = 10 * 1024 * 1024  # 10 MiB
+batch_write_size = config.batch_write_size
+
+max_buffer_size = config.max_buffer_size
 
 
 def store(datas, db_file=config.vdb_bin_file, index_file=config.vdb_bin_index):
     """Store data in the table
 
     :param datas: Data list to store
     :param db_file: DB file to use
     """
     data_list = serialize_vuln_list(datas)
+    packed_obj = None
     for batch in chunk_list(data_list, batch_write_size):
         index_list = []
         for data in batch:
             if data["details"]["cpe_uri"]:
-                vendor, _, _, cve_type = parse_cpe(data["details"]["cpe_uri"])
+                vendor, _, _, _ = parse_cpe(data["details"]["cpe_uri"])
                 if vendor:
                     index_list.append(
                         {
                             "id": data.get("id"),
                             "vendor": vendor.lower(),
                             "name": data["details"]["package"].lower(),
-                            "min_affected_version_including": data["details"].get(
-                                "min_affected_version_including"
-                            ),
-                            "max_affected_version_including": data["details"].get(
-                                "max_affected_version_including"
-                            ),
-                            "min_affected_version_excluding": data["details"].get(
-                                "min_affected_version_excluding"
-                            ),
-                            "max_affected_version_excluding": data["details"].get(
-                                "max_affected_version_excluding"
-                            ),
+                            "mii": data["details"].get("mii"),
+                            "mai": data["details"].get("mai"),
+                            "mie": data["details"].get("mie"),
+                            "mae": data["details"].get("mae"),
                         }
                     )
         packed_obj = msgpack.packb(batch, use_bin_type=True)
         with open(db_file, mode="ab") as fp:
             store_pos = fp.tell()
             fp.write(packed_obj)
             store_end_pos = fp.tell()
```

### Comparing `appthreat-vulnerability-db-5.1.4/vdb/lib/utils.py` & `appthreat-vulnerability-db-5.2.0/vdb/lib/utils.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import codecs
 import importlib
 import re
 import string
 from datetime import date, datetime
 from enum import Enum
 
 from cvss import CVSS3
@@ -59,14 +60,16 @@
 
     def _load(d):
         if isinstance(d, list):
             li = []
             for item in d:
                 li.append(_load(item))
             return li
+        elif isinstance(d, str) and ("\\n" in d or "\\t" in d):
+            return decompress_str(d)
         elif isinstance(d, dict) and "type" in d:  # object
             t = d["type"]
             if t == "datetime":
                 if hasattr(datetime, "fromisoformat"):
                     return datetime.fromisoformat(d["value"])
                 else:
                     return datetime.strptime(d["value"], date_format_str)
@@ -127,14 +130,15 @@
             if hasattr(obj, "isoformat"):
                 d["value"] = obj.isoformat()
             else:
                 d["value"] = obj.strftime(date_format_str)
             return d
         elif (
             isinstance(obj, str)
+            or isinstance(obj, bytes)
             or isinstance(obj, int)
             or isinstance(obj, float)
             or isinstance(obj, complex)
             or isinstance(obj, bool)
             or type(obj).__name__ == "NoneType"
         ):
             return obj
@@ -154,15 +158,15 @@
     :param datas: Data list to store
     :return List of serialized data
     """
     data_list = []
     for data in datas:
         ddata = data
         details = None
-        if type(data) != "dict":
+        if not isinstance(data, dict):
             ddata = vars(data)
             details = data.details
         else:
             details = data["details"]
         for vuln_detail in details:
             data_to_insert = ddata.copy()
             data_to_insert["details"] = vuln_detail
@@ -368,39 +372,39 @@
     return False
 
 
 def is_hash_mode(
     compare_ver,
     min_version,
     max_version,
-    min_affected_version_excluding,
-    max_affected_version_excluding,
+    mie,
+    mae,
 ):
     return (
         checkHex(compare_ver)
         or checkHex(min_version)
         or checkHex(max_version)
-        or checkHex(min_affected_version_excluding)
-        or checkHex(max_affected_version_excluding)
+        or checkHex(mie)
+        or checkHex(mae)
     )
 
 
 def is_epoch_mode(
     compare_ver,
     min_version,
     max_version,
-    min_affected_version_excluding,
-    max_affected_version_excluding,
+    mie,
+    mae,
 ):
     return (
         checkEpoch(compare_ver)
         or checkEpoch(min_version)
         or checkEpoch(max_version)
-        or checkEpoch(min_affected_version_excluding)
-        or checkEpoch(max_affected_version_excluding)
+        or checkEpoch(mie)
+        or checkEpoch(mae)
     )
 
 
 def trim_epoch_colon(s):
     if "ubuntu" not in s:
         m = DEBIAN_VALID_VERSION.search(s)
         if m and m.group("upstream_version"):
@@ -410,140 +414,117 @@
     return s
 
 
 def trim_epoch(
     compare_ver,
     min_version,
     max_version,
-    min_affected_version_excluding,
-    max_affected_version_excluding,
+    mie,
+    mae,
 ):
     if checkEpoch(compare_ver):
         compare_ver = trim_epoch_colon(compare_ver)
     if checkEpoch(min_version):
         min_version = trim_epoch_colon(min_version)
     if checkEpoch(max_version):
         max_version = trim_epoch_colon(max_version)
-    if checkEpoch(min_affected_version_excluding):
-        min_affected_version_excluding = trim_epoch_colon(
-            min_affected_version_excluding
-        )
-    if checkEpoch(max_affected_version_excluding):
-        max_affected_version_excluding = trim_epoch_colon(
-            max_affected_version_excluding
-        )
+    if checkEpoch(mie):
+        mie = trim_epoch_colon(mie)
+    if checkEpoch(mae):
+        mae = trim_epoch_colon(mae)
     return (
         compare_ver,
         min_version,
         max_version,
-        min_affected_version_excluding,
-        max_affected_version_excluding,
+        mie,
+        mae,
     )
 
 
 def version_compare(
     compare_ver,
     min_version,
     max_version,
-    min_affected_version_excluding=None,
-    max_affected_version_excluding=None,
+    mie=None,
+    mae=None,
 ):
     """Function to check if the given version is between min and max version
 
     >>> utils.version_compare("3.0.0", "2.0.0", "2.7.9.4")
     False
 
     >>> utils.version_compare("2.0.0", "2.0.0", "2.7.9.4")
     True
 
     >>> utils.version_compare("4.0.0", "2.0.0", "*")
     True
     """
     # Handle placeholder fix version
-    if max_affected_version_excluding == placeholder_fix_version and compare_ver:
+    if mae == placeholder_fix_version and compare_ver:
         return True
     # Fix min versions that are erroneously sent as *
-    if (
-        min_version
-        and min_version == "*"
-        and not min_affected_version_excluding
-        and max_affected_version_excluding
-        and "." in max_affected_version_excluding
-    ):
+    if min_version and min_version == "*" and not mie and mae and "." in mae:
         min_version = 0
     hash_mode_detected = is_hash_mode(
         compare_ver,
         min_version,
         max_version,
-        min_affected_version_excluding,
-        max_affected_version_excluding,
+        mie,
+        mae,
     )
     # Debian OS packages could have epoch. Detect and extract the upstream version
     epoch_mode_detected = is_epoch_mode(
         compare_ver,
         min_version,
         max_version,
-        min_affected_version_excluding,
-        max_affected_version_excluding,
+        mie,
+        mae,
     )
     ubuntu_mode_detected = False
     if epoch_mode_detected:
         # Easy check
-        if (
-            compare_ver
-            and max_affected_version_excluding
-            and compare_ver == max_affected_version_excluding
-        ):
+        if compare_ver and mae and compare_ver == mae:
             return False
         (
             tcompare_ver,
             tmin_version,
             tmax_version,
-            tmin_affected_version_excluding,
-            tmax_affected_version_excluding,
+            tmie,
+            tmae,
         ) = trim_epoch(
             compare_ver,
             min_version,
             max_version,
-            min_affected_version_excluding,
-            max_affected_version_excluding,
+            mie,
+            mae,
         )
         # 1.10-0ubuntu4 < 1.10-0ubuntu4.1
         if (
             tcompare_ver == tmax_version
-            or tcompare_ver == tmax_affected_version_excluding
+            or tcompare_ver == tmae
             or (max_version and max_version.startswith(compare_ver))
-            or (
-                max_affected_version_excluding
-                and max_affected_version_excluding.startswith(compare_ver)
-            )
+            or (mae and mae.startswith(compare_ver))
         ):
             if (
                 max_version
                 and max_version.startswith(compare_ver)
                 and max_version != compare_ver
             ):
                 return True
-            if (
-                max_affected_version_excluding
-                and max_affected_version_excluding.startswith(compare_ver)
-                and max_affected_version_excluding != compare_ver
-            ):
+            if mae and mae.startswith(compare_ver) and mae != compare_ver:
                 return True
         # Sorry about this but ubuntu versioning scheme is a PITA
         if "ubuntu" in compare_ver or "build" in compare_ver or "deb" in compare_ver:
             # Trim any epoch
             if ":" in compare_ver:
                 compare_ver = compare_ver.split(":")[-1]
             if max_version and ":" in max_version:
                 max_version = max_version.split(":")[-1]
-            if max_affected_version_excluding and ":" in max_affected_version_excluding:
-                max_affected_version_excluding = max_affected_version_excluding.split(
-                    ":"
-                )[-1]
+            if mae and ":" in mae:
+                mae = mae.split(":")[-1]
             if "ubuntu" in compare_ver:
                 tmpcvArr = compare_ver.split("ubuntu")
             elif "deb" in compare_ver:
                 tmpcvArr = compare_ver.split("deb")
             else:
                 tmpcvArr = compare_ver.split("build")
             ubuntu_mode_detected = True
@@ -559,88 +540,65 @@
                 elif "deb" in max_version:
                     tmpmv = max_version.split("deb")[indexToUse]
                 compare_ver = tmpcvArr[indexToUse]
                 if tmpmv:
                     max_version = tmpmv
                 if max_version and "-" in max_version:
                     max_version = max_version.split("-")[0]
-            elif max_affected_version_excluding and (
-                "ubuntu" in max_affected_version_excluding
-                or "deb" in max_affected_version_excluding
-                or "-" in max_affected_version_excluding
-            ):
+            elif mae and ("ubuntu" in mae or "deb" in mae or "-" in mae):
                 indexToUse = 0
-                if max_affected_version_excluding.startswith(tmpcvArr[0]):
+                if mae.startswith(tmpcvArr[0]):
                     indexToUse = -1
                 for bstr in ("ubuntu", "deb", "-"):
-                    if bstr in max_affected_version_excluding:
-                        tmpmvArr = max_affected_version_excluding.split(bstr)
+                    if bstr in mae:
+                        tmpmvArr = mae.split(bstr)
                         # If the prefix is equal after splitting operate with suffix alone
                         if tmpmvArr[0] == tmpcvArr[0]:
                             indexToUse = -1
                         tmpmv = tmpmvArr[indexToUse]
                         break
                 compare_ver = tmpcvArr[indexToUse]
-                max_affected_version_excluding = tmpmv
-                if (
-                    max_affected_version_excluding
-                    and "-" in max_affected_version_excluding
-                ):
-                    max_affected_version_excluding = (
-                        max_affected_version_excluding.split("-")[0]
-                    )
+                mae = tmpmv
+                if mae and "-" in mae:
+                    mae = mae.split("-")[0]
             if "-" in compare_ver:
                 compare_ver = compare_ver.split("-")[0]
             # If after splitting the versions are equal return False
             if (max_version and compare_ver == max_version) or (
-                max_affected_version_excluding
-                and compare_ver == max_affected_version_excluding
+                mae and compare_ver == mae
             ):
                 return False
-            if max_affected_version_excluding:
-                if VersionInfo.is_valid(compare_ver) and VersionInfo.is_valid(
-                    max_affected_version_excluding
-                ):
-                    cmp_value = VersionInfo.parse(compare_ver).compare(
-                        max_affected_version_excluding
-                    )
+            if mae:
+                if VersionInfo.is_valid(compare_ver) and VersionInfo.is_valid(mae):
+                    cmp_value = VersionInfo.parse(compare_ver).compare(mae)
                     return cmp_value < 0
-                elif (
-                    "." not in compare_ver and "." not in max_affected_version_excluding
-                ):
+                elif "." not in compare_ver and "." not in mae:
                     compare_ver = re.split(r"[+~]", compare_ver)[0]
-                    max_affected_version_excluding = re.split(
-                        r"[+~]", max_affected_version_excluding
-                    )[0]
+                    mae = re.split(r"[+~]", mae)[0]
                     exnum = list(filter(str.isdigit, compare_ver))
                     if exnum:
                         compare_ver_restnum = int("".join(exnum))
-                        exnum = list(
-                            filter(str.isdigit, max_affected_version_excluding)
-                        )
+                        exnum = list(filter(str.isdigit, mae))
                         if exnum:
-                            max_affected_version_excluding_restnum = int("".join(exnum))
-                            return (
-                                compare_ver_restnum
-                                < max_affected_version_excluding_restnum
-                            )
+                            mae_restnum = int("".join(exnum))
+                            return compare_ver_restnum < mae_restnum
         if not ubuntu_mode_detected:
             compare_ver = tcompare_ver
             min_version = tmin_version
             max_version = tmax_version
-            min_affected_version_excluding = tmin_affected_version_excluding
-            max_affected_version_excluding = tmax_affected_version_excluding
+            mie = tmie
+            mae = tmae
     # Semver compatible and including versions provided
     is_min_exclude = False
     is_max_exclude = False
-    if (not min_version or min_version == "*") and min_affected_version_excluding:
-        min_version = min_affected_version_excluding
+    if (not min_version or min_version == "*") and mie:
+        min_version = mie
         is_min_exclude = True
-    if (not max_version or max_version == "*") and max_affected_version_excluding:
-        max_version = max_affected_version_excluding
+    if (not max_version or max_version == "*") and mae:
+        max_version = mae
         is_max_exclude = True
     if not min_version:
         min_version = "0"
     # If compare_ver is semver compatible and min_version is * then max_version should be semver compatible
     if (
         compare_ver
         and VersionInfo.is_valid(compare_ver)
@@ -822,17 +780,17 @@
         return False
     if hash_mode_detected:
         if compare_ver:
             if compare_ver == min_version:
                 return True
             if compare_ver == max_version:
                 return True
-            if compare_ver == min_affected_version_excluding:
+            if compare_ver == mie:
                 return False
-            if compare_ver == max_affected_version_excluding:
+            if compare_ver == mae:
                 return False
         return False
     return True
 
 
 def parse_cpe(cpe_uri):
     """
@@ -917,18 +875,18 @@
                 problem_type=vobj["problem_type"],
                 type=package_type,
                 severity=vobj["severity"],
                 cvss_score=vobj["score"],
                 package_issue=PackageIssue(
                     affected_location=cpe_uri,
                     fixed_location=vdetails.fixed_location,
-                    min_affected_version_including=vdetails.min_affected_version_including,
-                    max_affected_version_including=vdetails.max_affected_version_including,
-                    min_affected_version_excluding=vdetails.min_affected_version_excluding,
-                    max_affected_version_excluding=vdetails.max_affected_version_excluding,
+                    mii=vdetails.mii,
+                    mai=vdetails.mai,
+                    mie=vdetails.mie,
+                    mae=vdetails.mae,
                 ),
                 short_description=vobj["description"],
                 long_description=None,
                 related_urls=vobj["related_urls"],
                 effective_severity=vobj["severity"],
             )
             id_list.append(unique_key)
@@ -1011,7 +969,19 @@
     except ValueError:
         return "LOW"
 
 
 def chunk_list(lst, size):
     for i in range(0, len(lst), size):
         yield lst[i : i + size]
+
+
+def compress_str(s):
+    """Compress string by replacing for newlines and tabs"""
+    return s.strip().replace("\n", "\\n").replace("  ", "\\t")
+
+
+def decompress_str(s):
+    """Decompress string by decoding escape characters"""
+    if isinstance(s, str):
+        s = bytes(s, "utf-8")
+    return codecs.escape_decode(s)[0].decode("utf-8")
```

