# Comparing `tmp/actoolkit-2.6.6b1-py3-none-any.whl.zip` & `tmp/actoolkit-2.6.6b2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,43 +1,43 @@
-Zip file size: 86045 bytes, number of entries: 41
--rw-r--r--  2.0 unx    20464 b- defN 23-Jun-06 13:16 toolkit.py
--rw-r--r--  2.0 unx      456 b- defN 23-Jun-06 13:16 astraSDK/__init__.py
--rw-r--r--  2.0 unx     3659 b- defN 23-Jun-06 13:16 astraSDK/apiresources.py
--rw-r--r--  2.0 unx    16835 b- defN 23-Jun-06 13:16 astraSDK/apps.py
--rw-r--r--  2.0 unx     8248 b- defN 23-Jun-06 13:16 astraSDK/backups.py
--rw-r--r--  2.0 unx     7321 b- defN 23-Jun-06 13:16 astraSDK/buckets.py
--rw-r--r--  2.0 unx     6972 b- defN 23-Jun-06 13:16 astraSDK/clouds.py
--rw-r--r--  2.0 unx     9155 b- defN 23-Jun-06 13:16 astraSDK/clusters.py
--rw-r--r--  2.0 unx     8083 b- defN 23-Jun-06 13:16 astraSDK/common.py
--rw-r--r--  2.0 unx     9115 b- defN 23-Jun-06 13:16 astraSDK/credentials.py
--rw-r--r--  2.0 unx     2663 b- defN 23-Jun-06 13:16 astraSDK/entitlements.py
--rw-r--r--  2.0 unx     7162 b- defN 23-Jun-06 13:16 astraSDK/hooks.py
--rw-r--r--  2.0 unx     5458 b- defN 23-Jun-06 13:16 astraSDK/namespaces.py
--rw-r--r--  2.0 unx     3511 b- defN 23-Jun-06 13:16 astraSDK/notifications.py
--rw-r--r--  2.0 unx     8803 b- defN 23-Jun-06 13:16 astraSDK/protections.py
--rw-r--r--  2.0 unx     9735 b- defN 23-Jun-06 13:16 astraSDK/replications.py
--rw-r--r--  2.0 unx     5758 b- defN 23-Jun-06 13:16 astraSDK/rolebindings.py
--rw-r--r--  2.0 unx     7091 b- defN 23-Jun-06 13:16 astraSDK/scripts.py
--rw-r--r--  2.0 unx     7035 b- defN 23-Jun-06 13:16 astraSDK/snapshots.py
--rw-r--r--  2.0 unx     2342 b- defN 23-Jun-06 13:16 astraSDK/storagebackends.py
--rw-r--r--  2.0 unx     4726 b- defN 23-Jun-06 13:16 astraSDK/storageclasses.py
--rw-r--r--  2.0 unx     4877 b- defN 23-Jun-06 13:16 astraSDK/users.py
--rw-r--r--  2.0 unx      255 b- defN 23-Jun-06 13:16 tkSrc/__init__.py
--rw-r--r--  2.0 unx     2634 b- defN 23-Jun-06 13:16 tkSrc/classes.py
--rw-r--r--  2.0 unx    12587 b- defN 23-Jun-06 13:16 tkSrc/clone.py
--rw-r--r--  2.0 unx    12203 b- defN 23-Jun-06 13:16 tkSrc/create.py
--rw-r--r--  2.0 unx     6193 b- defN 23-Jun-06 13:16 tkSrc/deploy.py
--rw-r--r--  2.0 unx     5461 b- defN 23-Jun-06 13:16 tkSrc/destroy.py
--rw-r--r--  2.0 unx    18774 b- defN 23-Jun-06 13:16 tkSrc/helpers.py
--rw-r--r--  2.0 unx     7300 b- defN 23-Jun-06 13:16 tkSrc/list.py
--rw-r--r--  2.0 unx     6629 b- defN 23-Jun-06 13:16 tkSrc/manage.py
--rw-r--r--  2.0 unx    52332 b- defN 23-Jun-06 13:16 tkSrc/parser.py
--rw-r--r--  2.0 unx     2193 b- defN 23-Jun-06 13:16 tkSrc/restore.py
--rw-r--r--  2.0 unx     3758 b- defN 23-Jun-06 13:16 tkSrc/unmanage.py
--rw-r--r--  2.0 unx    10226 b- defN 23-Jun-06 13:16 tkSrc/update.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Jun-06 13:16 actoolkit-2.6.6b1.dist-info/LICENSE
--rw-r--r--  2.0 unx     9365 b- defN 23-Jun-06 13:16 actoolkit-2.6.6b1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-06 13:16 actoolkit-2.6.6b1.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 23-Jun-06 13:16 actoolkit-2.6.6b1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       42 b- defN 23-Jun-06 13:16 actoolkit-2.6.6b1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3162 b- defN 23-Jun-06 13:16 actoolkit-2.6.6b1.dist-info/RECORD
-41 files, 324075 bytes uncompressed, 81149 bytes compressed:  75.0%
+Zip file size: 87090 bytes, number of entries: 41
+-rw-r--r--  2.0 unx    21212 b- defN 23-Jun-30 15:33 toolkit.py
+-rw-r--r--  2.0 unx     1077 b- defN 23-Jun-30 15:33 astraSDK/__init__.py
+-rw-r--r--  2.0 unx     3659 b- defN 23-Jun-30 15:33 astraSDK/apiresources.py
+-rw-r--r--  2.0 unx    16991 b- defN 23-Jun-30 15:33 astraSDK/apps.py
+-rw-r--r--  2.0 unx     8248 b- defN 23-Jun-30 15:33 astraSDK/backups.py
+-rw-r--r--  2.0 unx     7321 b- defN 23-Jun-30 15:33 astraSDK/buckets.py
+-rw-r--r--  2.0 unx     6972 b- defN 23-Jun-30 15:33 astraSDK/clouds.py
+-rw-r--r--  2.0 unx     9255 b- defN 23-Jun-30 15:33 astraSDK/clusters.py
+-rw-r--r--  2.0 unx     8052 b- defN 23-Jun-30 15:33 astraSDK/common.py
+-rw-r--r--  2.0 unx     9115 b- defN 23-Jun-30 15:33 astraSDK/credentials.py
+-rw-r--r--  2.0 unx     2663 b- defN 23-Jun-30 15:33 astraSDK/entitlements.py
+-rw-r--r--  2.0 unx     7162 b- defN 23-Jun-30 15:33 astraSDK/hooks.py
+-rw-r--r--  2.0 unx     5458 b- defN 23-Jun-30 15:33 astraSDK/namespaces.py
+-rw-r--r--  2.0 unx     3511 b- defN 23-Jun-30 15:33 astraSDK/notifications.py
+-rw-r--r--  2.0 unx     8803 b- defN 23-Jun-30 15:33 astraSDK/protections.py
+-rw-r--r--  2.0 unx     9735 b- defN 23-Jun-30 15:33 astraSDK/replications.py
+-rw-r--r--  2.0 unx     5757 b- defN 23-Jun-30 15:33 astraSDK/rolebindings.py
+-rw-r--r--  2.0 unx     7090 b- defN 23-Jun-30 15:33 astraSDK/scripts.py
+-rw-r--r--  2.0 unx     7035 b- defN 23-Jun-30 15:33 astraSDK/snapshots.py
+-rw-r--r--  2.0 unx     2434 b- defN 23-Jun-30 15:33 astraSDK/storagebackends.py
+-rw-r--r--  2.0 unx     5023 b- defN 23-Jun-30 15:33 astraSDK/storageclasses.py
+-rw-r--r--  2.0 unx     4877 b- defN 23-Jun-30 15:33 astraSDK/users.py
+-rw-r--r--  2.0 unx      846 b- defN 23-Jun-30 15:33 tkSrc/__init__.py
+-rw-r--r--  2.0 unx     2634 b- defN 23-Jun-30 15:33 tkSrc/classes.py
+-rw-r--r--  2.0 unx    12685 b- defN 23-Jun-30 15:33 tkSrc/clone.py
+-rw-r--r--  2.0 unx    12141 b- defN 23-Jun-30 15:33 tkSrc/create.py
+-rw-r--r--  2.0 unx     6206 b- defN 23-Jun-30 15:33 tkSrc/deploy.py
+-rw-r--r--  2.0 unx     5453 b- defN 23-Jun-30 15:33 tkSrc/destroy.py
+-rw-r--r--  2.0 unx    18584 b- defN 23-Jun-30 15:33 tkSrc/helpers.py
+-rw-r--r--  2.0 unx     7370 b- defN 23-Jun-30 15:33 tkSrc/list.py
+-rw-r--r--  2.0 unx     6527 b- defN 23-Jun-30 15:33 tkSrc/manage.py
+-rw-r--r--  2.0 unx    53212 b- defN 23-Jun-30 15:33 tkSrc/parser.py
+-rw-r--r--  2.0 unx     2197 b- defN 23-Jun-30 15:33 tkSrc/restore.py
+-rw-r--r--  2.0 unx     3601 b- defN 23-Jun-30 15:33 tkSrc/unmanage.py
+-rw-r--r--  2.0 unx    10107 b- defN 23-Jun-30 15:33 tkSrc/update.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Jun-30 15:33 actoolkit-2.6.6b2.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9365 b- defN 23-Jun-30 15:33 actoolkit-2.6.6b2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-30 15:33 actoolkit-2.6.6b2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 23-Jun-30 15:33 actoolkit-2.6.6b2.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       42 b- defN 23-Jun-30 15:33 actoolkit-2.6.6b2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3163 b- defN 23-Jun-30 15:33 actoolkit-2.6.6b2.dist-info/RECORD
+41 files, 327075 bytes uncompressed, 82194 bytes compressed:  74.9%
```

## zipnote {}

```diff
@@ -99,26 +99,26 @@
 
 Filename: tkSrc/unmanage.py
 Comment: 
 
 Filename: tkSrc/update.py
 Comment: 
 
-Filename: actoolkit-2.6.6b1.dist-info/LICENSE
+Filename: actoolkit-2.6.6b2.dist-info/LICENSE
 Comment: 
 
-Filename: actoolkit-2.6.6b1.dist-info/METADATA
+Filename: actoolkit-2.6.6b2.dist-info/METADATA
 Comment: 
 
-Filename: actoolkit-2.6.6b1.dist-info/WHEEL
+Filename: actoolkit-2.6.6b2.dist-info/WHEEL
 Comment: 
 
-Filename: actoolkit-2.6.6b1.dist-info/entry_points.txt
+Filename: actoolkit-2.6.6b2.dist-info/entry_points.txt
 Comment: 
 
-Filename: actoolkit-2.6.6b1.dist-info/top_level.txt
+Filename: actoolkit-2.6.6b2.dist-info/top_level.txt
 Comment: 
 
-Filename: actoolkit-2.6.6b1.dist-info/RECORD
+Filename: actoolkit-2.6.6b2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## toolkit.py

```diff
@@ -120,14 +120,25 @@
                 acl.apps = ard.buildList("apps", "id")
                 ard.destClusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
                 acl.destClusters = ard.buildList("destClusters", "id")
                 ard.backups = astraSDK.backups.getBackups().main()
                 acl.backups = ard.buildList("backups", "id")
                 ard.snapshots = astraSDK.snapshots.getSnaps().main()
                 acl.snapshots = ard.buildList("snapshots", "id")
+                # if the destination cluster has been specified, only show those storage classes
+                if (clusterID := list(set(argv) & set(acl.destClusters))) and len(clusterID) == 1:
+                    ard.storageClasses = astraSDK.storageclasses.getStorageClasses().main(
+                        clusterStr=clusterID[0], hideUnmanaged=True
+                    )
+                else:
+                    ard.storageClasses = astraSDK.storageclasses.getStorageClasses().main(
+                        hideUnmanaged=True
+                    )
+                acl.storageClasses = ard.buildList("storageClasses", "name")
+                acl.storageClasses = list(set(acl.storageClasses))
 
             elif verbs["restore"]:
                 ard.apps = astraSDK.apps.getApps().main()
                 acl.apps = ard.buildList("apps", "id")
 
                 # This expression translates to "Is there an arg after the verb we found?"
                 if len(argv) - verbPosition >= 2:
@@ -265,16 +276,17 @@
                     ard.protections = astraSDK.protections.getProtectionpolicies().main()
                     acl.protections = ard.buildList(
                         "protections", "id", fKey="appID", fVal=argv[verbPosition + 2]
                     )
                 elif argv[verbPosition + 1] == "replication" and len(argv) - verbPosition >= 3:
                     ard.replications = astraSDK.replications.getReplicationpolicies().main()
                     if not ard.replications:  # Gracefully handle ACS env
-                        print("Error: 'replication' commands are currently only supported in ACC.")
-                        sys.exit(1)
+                        raise SystemExit(
+                            "Error: 'replication' commands are currently only supported in ACC."
+                        )
                     acl.replications = ard.buildList("replications", "id")
                 elif argv[verbPosition + 1] == "snapshot" and len(argv) - verbPosition >= 3:
                     ard.apps = astraSDK.apps.getApps().main()
                     acl.apps = ard.buildList("apps", "id")
                     ard.snapshots = astraSDK.snapshots.getSnaps().main()
                     acl.snapshots = ard.buildList(
                         "snapshots", "id", fKey="appID", fVal=argv[verbPosition + 2]
@@ -339,49 +351,49 @@
                                 acl.credentials.append(credential["id"])
                 elif argv[verbPosition + 1] == "cluster":
                     ard.clusters = astraSDK.clusters.getClusters().main()
                     acl.clusters = ard.buildList("clusters", "id")
                 elif argv[verbPosition + 1] == "replication":
                     ard.replications = astraSDK.replications.getReplicationpolicies().main()
                     if not ard.replications:  # Gracefully handle ACS env
-                        print("Error: 'replication' commands are currently only supported in ACC.")
-                        sys.exit(1)
+                        raise SystemExit(
+                            "Error: 'replication' commands are currently only supported in ACC."
+                        )
                     acl.replications = ard.buildList("replications", "id")
                 elif argv[verbPosition + 1] == "script":
                     ard.scripts = astraSDK.scripts.getScripts().main()
                     acl.scripts = ard.buildList("scripts", "id")
 
     else:
-        print(
+        raise SystemExit(
             f"{argv[0]}: error: please specify a subcommand. Run '{argv[0]} -h' for "
             "parser information."
         )
-        sys.exit(1)
 
     # Manually passing args into argparse via parse_args() shouldn't include the function name
     argv = argv[1:] if "toolkit" in argv[0] else argv
     tkParser = tkSrc.parser.ToolkitParser(acl, plaidMode=plaidMode)
     parser = tkParser.main()
     args = parser.parse_args(args=argv)
 
     if args.subcommand == "deploy":
-        tkSrc.deploy.exec(args)
+        tkSrc.deploy.main(args)
+    elif args.subcommand == "clone":
+        tkSrc.clone.main(args, parser, ard)
+    elif args.subcommand == "restore":
+        tkSrc.restore.main(args, parser)
     elif args.subcommand == "list" or args.subcommand == "get":
-        tkSrc.list.exec(args)
+        tkSrc.list.main(args)
     elif args.subcommand == "create":
-        tkSrc.create.exec(args, parser, ard)
+        tkSrc.create.main(args, parser, ard)
     elif args.subcommand == "manage" or args.subcommand == "define":
-        tkSrc.manage.exec(args, parser)
+        tkSrc.manage.main(args, parser)
     elif args.subcommand == "destroy":
-        tkSrc.destroy.exec(args, parser, ard)
+        tkSrc.destroy.main(args, parser, ard)
     elif args.subcommand == "unmanage":
-        tkSrc.unmanage.exec(args, ard)
-    elif args.subcommand == "restore":
-        tkSrc.restore.exec(args, parser)
-    elif args.subcommand == "clone":
-        tkSrc.clone.exec(args, parser, ard)
+        tkSrc.unmanage.main(args, ard)
     elif args.subcommand == "update":
-        tkSrc.update.exec(args, parser, ard)
+        tkSrc.update.main(args, parser, ard)
 
 
 if __name__ == "__main__":
     main()
```

## astraSDK/__init__.py

```diff
@@ -1,7 +1,23 @@
+"""
+   Copyright 2023 NetApp, Inc
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+"""
+
 from . import apiresources
 from . import apps
 from . import backups
 from . import buckets
 from . import clouds
 from . import clusters
 from . import credentials
@@ -11,9 +27,10 @@
 from . import namespaces
 from . import notifications
 from . import protections
 from . import replications
 from . import rolebindings
 from . import scripts
 from . import snapshots
+from . import storagebackends
 from . import storageclasses
 from . import users
```

## astraSDK/apiresources.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/apps.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -312,14 +312,15 @@
 
     def main(
         self,
         cloneName,
         clusterID,
         sourceClusterID,
         namespaceMapping=None,
+        cloneStorageClass=None,
         backupID=None,
         snapshotID=None,
         sourceAppID=None,
         resourceFilter=None,
     ):
         assert backupID or snapshotID or sourceAppID
 
@@ -337,14 +338,16 @@
             data["sourceAppID"] = sourceAppID
         if backupID:
             data["backupID"] = backupID
         if snapshotID:
             data["snapshotID"] = snapshotID
         if namespaceMapping:
             data["namespaceMapping"] = namespaceMapping
+        if cloneStorageClass:
+            data["storageClassMapping"] = [{"destination": cloneStorageClass, "source": "*"}]
         if resourceFilter:
             data["restoreFilter"] = resourceFilter
 
         ret = super().apicall(
             "post",
             url,
             data,
```

## astraSDK/backups.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/buckets.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/clouds.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/clusters.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -205,23 +205,25 @@
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
         self.quiet = quiet
         self.verbose = verbose
         super().__init__()
         self.headers["accept"] = "application/astra-cluster+json"
         self.headers["Content-Type"] = "application/astra-cluster+json"
 
-    def main(self, cloudID, credentialID):
+    def main(self, cloudID, credentialID, privateRouteID=None):
         endpoint = f"topology/v1/clouds/{cloudID}/clusters"
         url = self.base + endpoint
         params = {}
         data = {
             "type": "application/astra-cluster",
-            "version": "1.1",
+            "version": "1.5",
             "credentialID": credentialID,
         }
+        if privateRouteID:
+            data["privateRouteID"] = privateRouteID
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
```

## astraSDK/common.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -56,23 +56,21 @@
             except IOError:
                 continue
             except yaml.YAMLError:
                 print(f"{configFile} not valid YAML")
                 continue
 
         if self.conf is None:
-            print("config.yaml not found.")
-            sys.exit(4)
+            raise SystemExit("config.yaml not found.")
 
         for item in ["astra_project", "uid", "headers"]:
             try:
                 assert self.conf.get(item) is not None
             except AssertionError:
-                print(f"{item} is a required field in {configFile}")
-                sys.exit(3)
+                raise SystemExit(f"{item} is a required field in {configFile}")
 
         if "." in self.conf.get("astra_project"):
             self.base = "https://%s/accounts/%s/" % (
                 self.conf.get("astra_project"),
                 self.conf.get("uid"),
             )
         else:
@@ -143,15 +141,15 @@
                 elif ret.status_code == 401:
                     print(
                         "API call to Astra Control failed: "
                         + colored("check Authorization in config.json", "red")
                     )
                 else:
                     print(
-                        f"API call to Astra Control failed: "
+                        "API call to Astra Control failed: "
                         + colored(f"{ret.status_code} - {ret.reason}", "red")
                     )
                     if ret.text.strip():
                         print(f"text: {ret.text.strip()}")
             else:
                 print("API call to Astra Control failed (Internal Server Error)")
                 print(f"API HTTP Status Code: {ret.status_code} - {ret.reason}")
```

## astraSDK/credentials.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/entitlements.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/hooks.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/namespaces.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/notifications.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/protections.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/replications.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/rolebindings.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -96,15 +96,15 @@
     def main(
         self,
         role,
         userID=None,
         groupID=None,
         roleConstraints=None,
     ):
-        endpoint = f"core/v1/roleBindings"
+        endpoint = "core/v1/roleBindings"
         url = self.base + endpoint
         params = {}
         data = {
             "type": "application/astra-roleBinding",
             "version": "1.1",
             "accountID": self.base.split("/")[4],
             "role": role,
```

## astraSDK/scripts.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -95,15 +95,15 @@
 
     def main(
         self,
         name,
         source,
         description=None,
     ):
-        endpoint = f"core/v1/hookSources"
+        endpoint = "core/v1/hookSources"
         url = self.base + endpoint
         params = {}
         data = {
             "type": "application/astra-hookSource",
             "version": "1.0",
             "name": name,
             "source": source,
```

## astraSDK/snapshots.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## astraSDK/storagebackends.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -57,16 +57,16 @@
             backends = super().jsonifyResults(ret)
             if self.output == "json":
                 dataReturn = backends
             elif self.output == "yaml":
                 dataReturn = yaml.dump(backends)
             elif self.output == "table":
                 dataReturn = self.basicTable(
-                    ["backendID", "backendName"],
-                    ["id", "backendName"],
+                    ["backendName", "backendID", "backendType", "healthState", "managedState"],
+                    ["backendName", "id", "backendType", "healthState", "managedState"],
                     backends,
                 )
             if not self.quiet:
                 print(json.dumps(dataReturn) if type(dataReturn) is dict else dataReturn)
             return dataReturn
 
         else:
```

## astraSDK/storageclasses.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -33,15 +33,15 @@
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
         super().__init__()
         self.clouds = getClouds(quiet=True, verbose=verbose).main()
         self.clusters = getClusters(quiet=True, verbose=verbose).main() if self.clouds else False
 
-    def main(self, cloudType=None):
+    def main(self, cloudType=None, clusterStr=None, hideUnmanaged=False):
         if self.clouds is False:
             print("getClouds().main() failed")
             return False
         elif self.clusters is False:
             print("getClusters().main() failed")
             return False
         if len(self.clouds["items"]) == 0:
@@ -56,14 +56,19 @@
         for cloud in self.clouds["items"]:
             for cluster in self.clusters["items"]:
                 # exclude invalid combinations of cloud/cluster
                 if (
                     cluster["cloudID"] != cloud["id"]
                     or cluster["managedState"] == "ineligible"
                     or (cloudType and cloud["cloudType"] != cloudType)
+                    or (
+                        clusterStr
+                        and not (cluster["id"] == clusterStr or cluster["name"] == clusterStr)
+                    )
+                    or (hideUnmanaged and cluster["managedState"] == "unmanaged")
                 ):
                     continue
                 endpoint = (
                     f"topology/v1/clouds/{cloud['id']}/clusters/{cluster['id']}/storageClasses"
                 )
                 url = self.base + endpoint
```

## astraSDK/users.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## tkSrc/__init__.py

```diff
@@ -1,7 +1,23 @@
+"""
+   Copyright 2023 NetApp, Inc
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+"""
+
 from . import classes
 from . import clone
 from . import create
 from . import deploy
 from . import destroy
 from . import helpers
 from . import list
```

## tkSrc/clone.py

```diff
@@ -26,14 +26,15 @@
 
 
 def doClone(
     cloneAppName,
     clusterID,
     oApp,
     namespaceMapping,
+    cloneStorageClass,
     backupID,
     snapshotID,
     sourceAppID,
     background,
     pollTimer,
     resourceFilter,
     verbose,
@@ -100,15 +101,15 @@
             if sourceIngress["metadata"]["managedFields"][0].get("time"):
                 del sourceIngress["metadata"]["managedFields"][0]["time"]
             sourceIngress["metadata"]["labels"]["app.kubernetes.io/instance"] = cloneNamespace
             sourceIngress["metadata"]["annotations"]["meta.helm.sh/release-name"] = cloneNamespace
             sourceIngress["metadata"]["annotations"][
                 "meta.helm.sh/release-namespace"
             ] = cloneNamespace
-        except:
+        except kubernetes.client.rest.ApiException:
             # In the event the sourceCluster no longer exists or isn't in kubeconfig
             sourceIngress = {
                 "kind": "IngressClass",
                 "apiVersion": "networking.k8s.io/v1",
                 "metadata": {
                     "name": "nginx",
                     "generation": 1,
@@ -177,55 +178,53 @@
                 raise SystemExit(f"Error: Kubernetes resource creation failed\n{e}")
 
     cloneRet = astraSDK.apps.cloneApp(verbose=verbose, quiet=quiet).main(
         cloneAppName,
         clusterID,
         oApp["clusterID"],
         namespaceMapping=namespaceMapping,
+        cloneStorageClass=cloneStorageClass,
         backupID=backupID,
         snapshotID=snapshotID,
         sourceAppID=sourceAppID,
         resourceFilter=resourceFilter,
     )
     if cloneRet:
         print("Submitting clone succeeded.")
         if background:
-            print(f"Background clone flag selected, run 'list apps' to get status.")
+            print("Background clone flag selected, run 'list apps' to get status.")
             return True
         print("Waiting for clone to become available.", end="")
         sys.stdout.flush()
         appID = cloneRet.get("id")
         state = cloneRet.get("state")
         while state != "ready":
             apps = astraSDK.apps.getApps().main()
             for app in apps["items"]:
                 if app["id"] == appID:
                     if app["state"] == "ready":
                         state = app["state"]
                         print("Cloning operation complete.")
                         sys.stdout.flush()
                     elif app["state"] == "failed":
-                        print(f"Error: \"{app['name']}\" in a failed state")
                         sys.stdout.flush()
-                        sys.exit(1)
+                        raise SystemExit(f"Error: \"{app['name']}\" in a failed state")
                     else:
                         print(".", end="")
                         sys.stdout.flush()
                         time.sleep(pollTimer)
     else:
-        print("Submitting clone failed.")
+        raise SystemExit("Submitting clone failed.")
 
 
-def exec(args, parser, ard):
+def main(args, parser, ard):
     if (args.filterSelection and not args.filterSet) or (
         args.filterSet and not args.filterSelection
     ):
-        parser.error(
-            f"either both or none of --filterSelection and --filterSet should be specified"
-        )
+        parser.error("either both or none of --filterSelection and --filterSet should be specified")
     if args.filterSet and args.sourceAppID:
         parser.error(
             "resource filters (--filterSet) may only be specified with --backupID "
             "or --snapshotID arguments, not --sourceAppID"
         )
     if not args.cloneAppName:
         args.cloneAppName = input("App name for the clone: ")
@@ -267,14 +266,15 @@
         )
 
     doClone(
         tkSrc.helpers.isRFC1123(args.cloneAppName),
         args.clusterID,
         oApp,
         tkSrc.helpers.createNamespaceMapping(oApp, args.cloneNamespace, args.multiNsMapping),
+        args.cloneStorageClass,
         args.backupID,
         args.snapshotID,
         args.sourceAppID,
         args.background,
         args.pollTimer,
         tkSrc.helpers.createFilterSet(
             args.filterSelection, args.filterSet, astraSDK.apps.getAppAssets().main(oApp["id"])
```

## tkSrc/create.py

```diff
@@ -28,15 +28,15 @@
 def doProtectionTask(protectionType, appID, name, background, pollTimer, quiet, verbose):
     """Take a snapshot/backup of appID giving it name <name>
     Return the snapshotID/backupID of the backup taken or False if the protection task fails"""
     if protectionType == "backup":
         protectionID = astraSDK.backups.takeBackup(quiet=quiet, verbose=verbose).main(appID, name)
     elif protectionType == "snapshot":
         protectionID = astraSDK.snapshots.takeSnap(quiet=quiet, verbose=verbose).main(appID, name)
-    if protectionID == False:
+    if protectionID is False:
         return False
 
     print(f"Starting {protectionType} of {appID}")
     if background:
         print(
             f"Background {protectionType} flag selected, run 'list {protectionType}s' to get status"
         )
@@ -66,28 +66,27 @@
                     print(f"{protectionType} job failed")
                     return False
         time.sleep(pollTimer)
         print(".", end="")
         sys.stdout.flush()
 
 
-def exec(args, parser, ard):
+def main(args, parser, ard):
     if args.objectType == "backup":
         rc = doProtectionTask(
             args.objectType,
             args.appID,
             tkSrc.helpers.isRFC1123(args.name),
             args.background,
             args.pollTimer,
             args.quiet,
             args.verbose,
         )
         if rc is False:
-            print("doProtectionTask() failed")
-            sys.exit(1)
+            raise SystemExit("doProtectionTask() failed")
     elif args.objectType == "cluster":
         with open(args.filePath, encoding="utf8") as f:
             kubeconfigDict = yaml.load(f.read().rstrip(), Loader=yaml.SafeLoader)
             encodedStr = base64.b64encode(json.dumps(kubeconfigDict).encode("utf-8")).decode(
                 "utf-8"
             )
         rc = astraSDK.credentials.createCredential(quiet=args.quiet, verbose=args.verbose).main(
@@ -96,20 +95,20 @@
             {"base64": encodedStr},
             cloudName="private",
         )
         if rc:
             rc = astraSDK.clusters.addCluster(quiet=args.quiet, verbose=args.verbose).main(
                 args.cloudID,
                 rc["id"],
+                privateRouteID=args.privateRouteID,
             )
             if rc is False:
-                print("astraSDK.clusters.createCluster() failed")
+                raise SystemExit("astraSDK.clusters.createCluster() failed")
         else:
-            print("astraSDK.credentials.createCredential() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.credentials.createCredential() failed")
     elif args.objectType == "hook":
         rc = astraSDK.hooks.createHook(quiet=args.quiet, verbose=args.verbose).main(
             args.appID,
             args.name,
             args.scriptID,
             args.operation.split("-")[0],
             args.operation.split("-")[1],
@@ -119,15 +118,15 @@
                 args.namespace,
                 args.podName,
                 args.label,
                 args.containerName,
             ),
         )
         if rc is False:
-            print("astraSDK.hooks.createHook() failed")
+            raise SystemExit("astraSDK.hooks.createHook() failed")
     elif args.objectType == "protection" or args.objectType == "protectionpolicy":
         if args.granularity == "hourly":
             if args.hour:
                 parser.error("'hourly' granularity must not specify -H / --hour")
             args.hour = "*"
             args.dayOfWeek = "*"
             args.dayOfMonth = "*"
@@ -159,16 +158,15 @@
             str(args.dayOfWeek),
             str(args.dayOfMonth),
             str(args.hour),
             str(args.minute),
             args.appID,
         )
         if rc is False:
-            print("astraSDK.protections.createProtectionpolicy() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.protections.createProtectionpolicy() failed")
     elif args.objectType == "replication":
         # Validate offset values and create DTSTART string
         if ":" in args.offset:
             hours = args.offset.split(":")[0].zfill(2)
             minutes = args.offset.split(":")[1].zfill(2)
         else:
             hours = "00"
@@ -218,40 +216,37 @@
                 None,
                 None,
                 None,
                 args.appID,
                 dtstart + rrule,
             )
             if prc is False:
-                print("astraSDK.protections.createProtectionpolicy() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.protections.createProtectionpolicy() failed")
         else:
-            print("astraSDK.replications.createReplicationpolicy() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.replications.createReplicationpolicy() failed")
     elif args.objectType == "script":
         with open(args.filePath, encoding="utf8") as f:
             encodedStr = base64.b64encode(f.read().rstrip().encode("utf-8")).decode("utf-8")
         rc = astraSDK.scripts.createScript(quiet=args.quiet, verbose=args.verbose).main(
             name=args.name, source=encodedStr, description=args.description
         )
         if rc is False:
-            print("astraSDK.scripts.createScript() failed")
+            raise SystemExit("astraSDK.scripts.createScript() failed")
     elif args.objectType == "snapshot":
         rc = doProtectionTask(
             args.objectType,
             args.appID,
             tkSrc.helpers.isRFC1123(args.name),
             args.background,
             args.pollTimer,
             args.quiet,
             args.verbose,
         )
         if rc is False:
-            print("doProtectionTask() failed")
-            sys.exit(1)
+            raise SystemExit("doProtectionTask() failed")
     elif args.objectType == "user":
         # First create the user
         urc = astraSDK.users.createUser(quiet=args.quiet, verbose=args.verbose).main(
             args.email, firstName=args.firstName, lastName=args.lastName
         )
         if urc:
             # Next create the role binding
@@ -263,19 +258,18 @@
                 roleConstraints=tkSrc.helpers.createConstraintList(
                     args.namespaceConstraint, args.labelConstraint
                 ),
             )
             if rrc:
                 # Delete+error "local" users where a tempPassword wasn't provided
                 if urc["authProvider"] == "local" and not args.tempPassword:
-                    print("Error: --tempPassword is required for ACC+localAuth")
                     drc = astraSDK.rolebindings.destroyRolebinding(quiet=True).main(rrc["id"])
                     if not drc:
-                        print("astraSDK.rolebindings.destroyRolebinding() failed")
-                    sys.exit(1)
+                        raise SystemExit("astraSDK.rolebindings.destroyRolebinding() failed")
+                    raise SystemExit("Error: --tempPassword is required for ACC+localAuth")
                 # Finally, create the credential if local user
                 if urc["authProvider"] == "local":
                     crc = astraSDK.credentials.createCredential(
                         quiet=args.quiet, verbose=args.verbose
                     ).main(
                         urc["id"],
                         "passwordHash",
@@ -283,15 +277,12 @@
                             "cleartext": base64.b64encode(args.tempPassword.encode("utf-8")).decode(
                                 "utf-8"
                             ),
                             "change": base64.b64encode("true".encode("utf-8")).decode("utf-8"),
                         },
                     )
                     if not crc:
-                        print("astraSDK.credentials.createCredential() failed")
-                        sys.exit(1)
+                        raise SystemExit("astraSDK.credentials.createCredential() failed")
             else:
-                print("astraSDK.rolebindings.createRolebinding() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.rolebindings.createRolebinding() failed")
         else:
-            print("astraSDK.users.createUser() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.users.createUser() failed")
```

## tkSrc/deploy.py

```diff
@@ -33,16 +33,15 @@
     valueStr = tkSrc.helpers.createHelmStr("values", fileValues)
 
     nsObj = astraSDK.namespaces.getNamespaces(verbose=verbose)
     retval = tkSrc.helpers.run("kubectl get ns -o json", captureOutput=True)
     retvalJSON = json.loads(retval)
     for item in retvalJSON["items"]:
         if item["metadata"]["name"] == namespace:
-            print(f"Namespace {namespace} already exists!")
-            sys.exit(24)
+            raise SystemExit(f"Namespace {namespace} already exists!")
     tkSrc.helpers.run(f"kubectl create namespace {namespace}")
     tkSrc.helpers.run(f"kubectl config set-context --current --namespace={namespace}")
 
     # If we're deploying gitlab, we need to ensure at least a premium storageclass
     # for postgresql and gitaly
     if chart.split("/")[1] == "gitlab":
         pgStorageClass = None
@@ -114,15 +113,15 @@
                         ns["name"], ns["name"], ns["clusterID"]
                     )
                     if rc:
                         appID = rc["id"]
                         print("Success!")
                         break
                     else:
-                        sys.exit(1)
+                        raise SystemExit("Error managing app")
 
     # Create a protection policy on that namespace (using its appID)
     time.sleep(5)
     backupRetention = "1"
     snapshotRetention = "1"
     minute = "0"
     cpp = astraSDK.protections.createProtectionpolicy(quiet=True)
@@ -147,15 +146,15 @@
             minute,
             appID,
         )
         if cppRet is False:
             raise SystemExit(f"cpp.main({period}...) returned False")
 
 
-def exec(args):
+def main(args):
     doDeploy(
         args.chart,
         tkSrc.helpers.isRFC1123(args.app),
         args.namespace,
         args.set,
         args.values,
         args.verbose,
```

## tkSrc/destroy.py

```diff
@@ -11,52 +11,50 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
-import sys
-
 import astraSDK
 
 
-def exec(args, parser, ard):
+def main(args, parser, ard):
     if args.objectType == "backup":
         rc = astraSDK.backups.destroyBackup(quiet=args.quiet, verbose=args.verbose).main(
             args.appID, args.backupID
         )
         if rc:
             print(f"Backup {args.backupID} destroyed")
         else:
-            print(f"Failed destroying backup: {args.backupID}")
+            raise SystemExit(f"Failed destroying backup: {args.backupID}")
     elif args.objectType == "credential":
         rc = astraSDK.credentials.destroyCredential(quiet=args.quiet, verbose=args.verbose).main(
             args.credentialID
         )
         if rc:
             print(f"Credential {args.credentialID} destroyed")
         else:
-            print(f"Failed destroying credential: {args.credentialID}")
+            raise SystemExit(f"Failed destroying credential: {args.credentialID}")
     elif args.objectType == "hook":
         rc = astraSDK.hooks.destroyHook(quiet=args.quiet, verbose=args.verbose).main(
             args.appID, args.hookID
         )
         if rc:
             print(f"Hook {args.hookID} destroyed")
         else:
-            print(f"Failed destroying hook: {args.hookID}")
+            raise SystemExit(f"Failed destroying hook: {args.hookID}")
     elif args.objectType == "protection":
         rc = astraSDK.protections.destroyProtectiontionpolicy(
             quiet=args.quiet, verbose=args.verbose
         ).main(args.appID, args.protectionID)
         if rc:
             print(f"Protection policy {args.protectionID} destroyed")
         else:
-            print(f"Failed destroying protection policy: {args.protectionID}")
+            raise SystemExit(f"Failed destroying protection policy: {args.protectionID}")
     elif args.objectType == "replication":
         if ard.needsattr("replications"):
             ard.replications = astraSDK.replications.getReplicationpolicies().main()
         rc = astraSDK.replications.destroyReplicationpolicy(
             quiet=args.quiet, verbose=args.verbose
         ).main(args.replicationID)
         if rc:
@@ -71,52 +69,50 @@
                             protection["appID"] == replication["sourceAppID"]
                             or protection["appID"] == replication["destinationAppID"]
                         ) and protection.get("replicate") == "true":
                             if astraSDK.protections.destroyProtectiontionpolicy(
                                 quiet=args.quiet, verbose=args.verbose
                             ).main(protection["appID"], protection["id"]):
                                 print(
-                                    "Underlying replication schedule "
-                                    + f"{protection['id']} destroyed"
+                                    f"Underlying replication schedule {protection['id']} destroyed"
                                 )
                             else:
-                                print(
+                                raise SystemExit(
                                     "Failed destroying underlying replication "
                                     + f"schedule: {protection['id']}"
                                 )
-                                sys.exit(1)
         else:
-            print(f"Failed destroying replication policy: {args.replicationID}")
-            sys.exit(1)
+            raise SystemExit(f"Failed destroying replication policy: {args.replicationID}")
     elif args.objectType == "script":
         rc = astraSDK.scripts.destroyScript(quiet=args.quiet, verbose=args.verbose).main(
             args.scriptID
         )
         if rc:
             print(f"Script {args.scriptID} destroyed")
         else:
-            print(f"Failed destroying script: {args.scriptID}")
+            raise SystemExit(f"Failed destroying script: {args.scriptID}")
     elif args.objectType == "snapshot":
         rc = astraSDK.snapshots.destroySnapshot(quiet=args.quiet, verbose=args.verbose).main(
             args.appID, args.snapshotID
         )
         if rc:
             print(f"Snapshot {args.snapshotID} destroyed")
         else:
-            print(f"Failed destroying snapshot: {args.snapshotID}")
+            raise SystemExit(f"Failed destroying snapshot: {args.snapshotID}")
     elif args.objectType == "user":
         userDestroyed = False
         roleBindings = astraSDK.rolebindings.getRolebindings().main()
         for rb in roleBindings["items"]:
             if rb["userID"] == args.userID:
                 rc = astraSDK.rolebindings.destroyRolebinding(
                     quiet=args.quiet, verbose=args.verbose
                 ).main(rb["id"])
                 if rc:
                     print(f"User {args.userID} / roleBinding {rb['id']} destroyed")
                     userDestroyed = True
                 else:
-                    print(f"Failed destroying user {args.userID} with roleBinding {rb['id']}")
-                    sys.exit(1)
+                    raise SystemExit(
+                        f"Failed destroying user {args.userID} with roleBinding {rb['id']}"
+                    )
         if not userDestroyed:
             # If we reached this point, it's due to plaidMode == True and bad userID
             parser.error(f"userID {args.userID} not found")
```

## tkSrc/helpers.py

```diff
@@ -15,15 +15,14 @@
    limitations under the License.
 """
 
 import json
 import os
 import re
 import subprocess
-import sys
 import tempfile
 import yaml
 
 
 def subKeys(subObject, key):
     """Short recursion function for when the userSelect dict object has another
     dict as one of its key's values"""
@@ -136,16 +135,15 @@
 def createNamespaceMapping(app, singleNs, multiNsMapping):
     """Create a list of dictionaries of source and destination namespaces for cloning an
     application, as the user can provide a variety of input.  Return object format:
     [ { "source": "sourcens1", "destination": "destns1" },
       { "source": "sourcens2", "destination": "destns2" } ]"""
     # Ensure that multiNsMapping was used for multi-namespace apps
     if multiNsMapping is None and len(app["namespaceScopedResources"]) > 1:
-        print("Error: for multi-namespace apps, --multiNsMapping must be used.")
-        sys.exit(1)
+        raise SystemExit("Error: for multi-namespace apps, --multiNsMapping must be used.")
     # For single-namespace apps, the namespace mapping is **not** a required field
     elif singleNs is None and multiNsMapping is None:
         return None
     # Handle --cloneNamespace argument
     elif singleNs:
         return [
             {
@@ -162,53 +160,49 @@
                 for mapping in NsMapping:
                     mappingList.append(mapping)
             else:
                 mappingList.append(NsMapping)
         # Ensure the mappings are of 'sourcens=destns' format
         for mapping in mappingList:
             if len(mapping.split("=")) != 2:
-                print(f"Error: '{mapping}' does not conform to 'sourcens=destns' format")
-                sys.exit(1)
+                raise SystemExit(f"Error: '{mapping}' does not conform to 'sourcens=destns' format")
         # Ensure that the user-provided source mapping equals the app namespaces
         sortedMappingSourceNs = sorted([i.split("=")[0] for i in mappingList])
         sortedAppSourceNs = sorted([i["namespace"] for i in app["namespaceScopedResources"]])
         if sortedMappingSourceNs != sortedAppSourceNs:
-            print(
+            raise SystemExit(
                 "Error: the source namespaces provided by --multiNsMapping do not match the "
                 + f"namespaces in the source app:\nsourceApp:\t{sortedAppSourceNs}"
                 + f"\nmultiNsMapping:\t{sortedMappingSourceNs}"
             )
-            sys.exit(1)
         # Generate the return mapping list and return it
         returnList = []
         for mapping in mappingList:
             returnList.append(
                 {"source": mapping.split("=")[0], "destination": isRFC1123(mapping.split("=")[1])}
             )
         return returnList
     else:
-        print("Unknown Error")
-        sys.exit(1)
+        raise SystemExit("Unknown Error")
 
 
 def createNamespaceList(namespaceArguments):
     """Create a list of dictionaries of namespace key/value and (optionally) labelSelectors
     key/value(list) for managing an app, as nargs="*" can provide a variety of input."""
     returnList = []
     for mapping in namespaceArguments:
         returnList.append({"namespace": mapping[0]})
         if len(mapping) == 2:
             returnList[-1]["labelSelectors"] = [mapping[1]]
         elif len(mapping) > 2:
-            print(
+            raise SystemExit(
                 "Error: --additionalNamespace should have at most two arguments per flag:\n"
                 + "  -a namespace1\n  -a namespace1 app=appname\n"
                 + "  -a namespace1 -a namespace2 app=app2name"
             )
-            sys.exit(1)
     return returnList
 
 
 def createCsrList(CSRs, apiResourcesDict):
     """Create a list of dictionaries of clusterScopedResources and (optionally) labelSelectors
     key/value(list) for managing an app, as nargs="*" can provide a variety of input."""
     returnList = []
@@ -223,26 +217,24 @@
                             "version": resource["apiVersion"].split("/")[1],
                         }
                     }
                 )
                 if len(csr) == 2:
                     returnList[-1]["labelSelectors"] = [csr[1]]
                 elif len(csr) > 2:
-                    print(
+                    raise SystemExit(
                         "Error: --clusterScopedResource should have at most two arguments per "
                         + "flag:\n  -a csr-kind1\n  -a csr-kind1 app=appname\n"
                         + "  -a csr-kind1 -a csr-kind2 app=app2name"
                     )
-                    sys.exit(1)
     if len(returnList) == 0:
-        print(
+        raise SystemExit(
             "Error: matching clusterScopedResource kind not found, please ensure the kind "
             + "is correct via 'list apiresources'"
         )
-        sys.exit(1)
     return returnList
 
 
 def createConstraintList(idList, labelList):
     """Create a list of strings to be used for --labelConstraint and --namespaceConstraint args,
     as nargs="*" can provide a varitey of different types of lists of lists depending on input."""
     returnList = []
@@ -331,52 +323,48 @@
     tmp.seek(0)
     # Use os.system a few times because the home rolled run() simply isn't up to the task
     try:
         # TODO: I suspect these gymnastics wouldn't be needed if the py-k8s module
         # were used
         ret = os.system(f'kubectl patch statefulset.apps/{stsName} -p "$(cat {tmp.name})"')
     except OSError as e:
-        print(f"Exception: {e}")
-        sys.exit(11)
+        raise SystemExit(f"Exception: {e}")
     if ret:
-        print(f"os.system exited with RC: {ret}")
-        sys.exit(12)
+        raise SystemExit(f"os.system exited with RC: {ret}")
     tmp.close()
     try:
         os.system(
             f"kubectl scale sts {stsName} --replicas=0 && "
             f"sleep 10 && kubectl scale sts {stsName} --replicas=1"
         )
     except OSError as e:
-        print(f"Exception: {e}")
-        sys.exit(13)
+        raise SystemExit(f"Exception: {e}")
     if ret:
-        print(f"os.system exited with RC: {ret}")
-        sys.exit(14)
+        raise SystemExit(f"os.system exited with RC: {ret}")
 
 
 def isRFC1123(string):
     """isRFC1123 returns the input 'string' if it conforms to RFC 1123 spec,
     otherwise it throws an error and exits with code 15"""
     regex = re.compile("[a-z0-9]([-a-z0-9]*[a-z0-9])?$")
     if regex.match(string) is not None and len(string) < 64:
         return string
     else:
-        print(
+        raise SystemExit(
             f"Error: '{string}' must consist of lower case alphanumeric characters or '-', must "
             + "start and end with an alphanumeric character, and must be at most 63 characters "
             + "(for example 'my-name' or '123-abc')."
         )
-        sys.exit(15)
 
 
 def dupeKeyError(key):
     """Print an error message if duplicate keys are used"""
-    print(f"Error: '{key}' should not be specified multiple times within a single --filterSet arg")
-    sys.exit(1)
+    raise SystemExit(
+        f"Error: '{key}' should not be specified multiple times within a single --filterSet arg"
+    )
 
 
 def createSetDict(setDict, filterStr, assets):
     """Given a filterStr such as:
         label=app.kubernetes.io/tier=backend,name=mysql,kind=Deployment
     Return a setDict with the following format:
         {
@@ -397,42 +385,39 @@
         elif "group" in key:
             setDict["group"] = val if not setDict.get("group") else dupeKeyError("group")
         elif "version" in key:
             setDict["version"] = val if not setDict.get("version") else dupeKeyError("version")
         elif "kind" in key:
             setDict["kind"] = val if not setDict.get("kind") else dupeKeyError("kind")
         else:
-            print(
+            raise SystemExit(
                 f"Error: '{key}' not one of ['namespace', 'name', 'label', 'group', 'version', "
                 "'kind']"
             )
-            sys.exit(1)
     # Validate the inputs are valid assets for this app
     for key in ["group", "version", "kind"]:
         if setDict.get(key) and setDict[key] not in [a["GVK"][key] for a in assets["items"]]:
-            print(
+            raise SystemExit(
                 f"Error: '{setDict[key]}' is not a valid '{key}' for this application, please run "
                 f"'list assets {assets['metadata']['appID']}' to view possible '{key}' choices"
             )
-            sys.exit(1)
     # Validate the inputs are valid GVK combinations
     for key1 in ["group", "version", "kind"]:
         for key2 in ["group", "version", "kind"]:
             if key1 == key2:
                 continue
             if setDict.get(key1) and setDict.get(key2):
                 if setDict[key1] not in [
                     a["GVK"][key1] for a in assets["items"] if a["GVK"][key2] == setDict[key2]
                 ]:
-                    print(
+                    raise SystemExit(
                         f"Error: '{key1}={setDict[key1]}' does not match with "
                         f"'{key2}={setDict[key2]}', please run 'list assets "
                         f"{assets['metadata']['appID']}' to view valid GVK combinations"
                     )
-                    sys.exit(1)
 
 
 def createFilterSet(selection, filters, assets):
     """createFilterSet takes in a selection string, and a filters array of arrays, for example:
         [
             ['group=apps,version=v1,kind=Deployment'],
             ['label=app.kubernetes.io/tier=backend,name=mysql,namespace=wordpress']
```

## tkSrc/list.py

```diff
@@ -12,168 +12,155 @@
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import base64
-import sys
 
 import astraSDK
 
-def exec(args):
+
+def main(args):
     if args.objectType == "apiresources":
         rc = astraSDK.apiresources.getApiResources(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(cluster=args.cluster)
         if rc is False:
-            print("astraSDK.apiresources.getApiResources() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.apiresources.getApiResources() failed")
     elif args.objectType == "apps":
-        rc = astraSDK.apps.getApps(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
-        ).main(
+        rc = astraSDK.apps.getApps(quiet=args.quiet, verbose=args.verbose, output=args.output).main(
             namespace=args.namespace,
             nameFilter=args.nameFilter,
             cluster=args.cluster,
         )
         if rc is False:
-            print("astraSDK.apps.getApps() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.apps.getApps() failed")
     elif args.objectType == "assets":
         rc = astraSDK.apps.getAppAssets(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(args.appID)
         if rc is False:
-            print("astraSDK.apps.getAppAssets() failed")
+            raise SystemExit("astraSDK.apps.getAppAssets() failed")
     elif args.objectType == "backups":
         rc = astraSDK.backups.getBackups(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(appFilter=args.app)
         if rc is False:
-            print("astraSDK.backups.getBackups() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.backups.getBackups() failed")
     elif args.objectType == "buckets":
         rc = astraSDK.buckets.getBuckets(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(nameFilter=args.nameFilter, provider=args.provider)
         if rc is False:
-            print("astraSDK.buckets.getBuckets() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.buckets.getBuckets() failed")
     elif args.objectType == "clouds":
         rc = astraSDK.clouds.getClouds(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(cloudType=args.cloudType)
         if rc is False:
-            print("astraSDK.clouds.getClouds() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.clouds.getClouds() failed")
     elif args.objectType == "clusters":
         rc = astraSDK.clusters.getClusters(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(
             hideManaged=args.hideManaged,
             hideUnmanaged=args.hideUnmanaged,
             nameFilter=args.nameFilter,
         )
         if rc is False:
-            print("astraSDK.clusters.getClusters() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.clusters.getClusters() failed")
     elif args.objectType == "credentials":
         rc = astraSDK.credentials.getCredentials(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(kubeconfigOnly=args.kubeconfigOnly)
         if rc is False:
-            print("astraSDK.credentials.getCredentials() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.credentials.getCredentials() failed")
     elif args.objectType == "hooks":
         rc = astraSDK.hooks.getHooks(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(appFilter=args.app)
         if rc is False:
-            print("astraSDK.hooks.getHooks() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.hooks.getHooks() failed")
     elif args.objectType == "protections":
         rc = astraSDK.protections.getProtectionpolicies(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(appFilter=args.app)
         if rc is False:
-            print("astraSDK.protections.getProtectionpolicies() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.protections.getProtectionpolicies() failed")
     elif args.objectType == "replications":
         rc = astraSDK.replications.getReplicationpolicies(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(appFilter=args.app)
         if rc is False:
-            print("astraSDK.replications.getReplicationpolicies() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.replications.getReplicationpolicies() failed")
     elif args.objectType == "namespaces":
         rc = astraSDK.namespaces.getNamespaces(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(
             clusterID=args.clusterID,
             nameFilter=args.nameFilter,
             showRemoved=args.showRemoved,
             unassociated=args.unassociated,
             minuteFilter=args.minutes,
         )
         if rc is False:
-            print("astraSDK.namespaces.getNamespaces() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.namespaces.getNamespaces() failed")
     elif args.objectType == "notifications":
         rc = astraSDK.notifications.getNotifications(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(
             limit=args.limit,
             skip=args.offset,
             minuteFilter=args.minutes,
             severityFilter=args.severity,
         )
         if rc is False:
-            print("astraSDK.namespaces.getNotifications() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.namespaces.getNotifications() failed")
     elif args.objectType == "rolebindings":
         rc = astraSDK.rolebindings.getRolebindings(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(idFilter=args.idFilter)
         if rc is False:
-            print("astraSDK.rolebindings.getRolebindings() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.rolebindings.getRolebindings() failed")
     elif args.objectType == "scripts":
         if args.getScriptSource:
             args.quiet = True
             args.output = "json"
         rc = astraSDK.scripts.getScripts(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(nameFilter=args.nameFilter)
         if rc is False:
-            print("astraSDK.scripts.getScripts() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.scripts.getScripts() failed")
         else:
             if args.getScriptSource:
                 if len(rc["items"]) == 0:
                     print(f"Script of name '{args.nameFilter}' not found.")
                 for script in rc["items"]:
                     print("#" * len(f"### {script['name']} ###"))
                     print(f"### {script['name']} ###")
                     print("#" * len(f"### {script['name']} ###"))
                     print(base64.b64decode(script["source"]).decode("utf-8"))
     elif args.objectType == "snapshots":
         rc = astraSDK.snapshots.getSnaps(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(appFilter=args.app)
         if rc is False:
-            print("astraSDK.snapshots.getSnaps() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.snapshots.getSnaps() failed")
+    elif args.objectType == "storagebackends":
+        rc = astraSDK.storagebackends.getStorageBackends(
+            quiet=args.quiet, verbose=args.verbose, output=args.output
+        ).main()
+        if rc is False:
+            raise SystemExit("astraSDK.backups.getBackends() failed")
     elif args.objectType == "storageclasses":
         rc = astraSDK.storageclasses.getStorageClasses(
             quiet=args.quiet, verbose=args.verbose, output=args.output
-        ).main(cloudType=args.cloudType)
+        ).main(cloudType=args.cloudType, clusterStr=args.cluster)
         if rc is False:
-            print("astraSDK.storageclasses.getStorageClasses() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.storageclasses.getStorageClasses() failed")
     elif args.objectType == "users":
         rc = astraSDK.users.getUsers(
             quiet=args.quiet, verbose=args.verbose, output=args.output
         ).main(nameFilter=args.nameFilter)
         if rc is False:
-            print("astraSDK.users.getUsers() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.users.getUsers() failed")
```

## tkSrc/manage.py

```diff
@@ -13,21 +13,20 @@
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import base64
 import json
-import sys
 
 import astraSDK
 import tkSrc
 
 
-def exec(args, parser):
+def main(args, parser):
     if args.objectType == "app":
         if args.additionalNamespace:
             args.additionalNamespace = tkSrc.helpers.createNamespaceList(args.additionalNamespace)
         if args.clusterScopedResource:
             apiResourcesDict = astraSDK.apiresources.getApiResources().main(cluster=args.clusterID)
             # Validate input as argparse+choices is unable to only validate the first input
             for csr in args.clusterScopedResource:
@@ -44,48 +43,45 @@
             args.namespace,
             args.clusterID,
             args.labelSelectors,
             addNamespaces=args.additionalNamespace,
             clusterScopedResources=args.clusterScopedResource,
         )
         if rc is False:
-            print("astraSDK.apps.manageApp() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.apps.manageApp() failed")
     elif args.objectType == "bucket":
         # Validate that both credentialID and accessKey/accessSecret were not specified
         if args.credentialID is not None and (
             args.accessKey is not None or args.accessSecret is not None
         ):
             parser.error(
-                f"if a credentialID is specified, neither accessKey nor accessSecret"
+                "if a credentialID is specified, neither accessKey nor accessSecret"
                 + " should be specified."
             )
         # Validate args and create credential if credentialID was not specified
         if args.credentialID is None:
             if args.accessKey is None or args.accessSecret is None:
                 parser.error(
                     "if a credentialID is not specified, both accessKey and "
                     + "accessSecret arguments must be provided."
                 )
-                sys.exit(1)
             encodedKey = base64.b64encode(args.accessKey.encode("utf-8")).decode("utf-8")
             encodedSecret = base64.b64encode(args.accessSecret.encode("utf-8")).decode("utf-8")
             crc = astraSDK.credentials.createCredential(
                 quiet=args.quiet, verbose=args.verbose
             ).main(
                 args.bucketName,
                 "s3",
                 {"accessKey": encodedKey, "accessSecret": encodedSecret},
                 cloudName="s3",
             )
             if crc:
                 args.credentialID = crc["id"]
             else:
-                print("astraSDK.credentials.createCredential() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Validate serverURL and storageAccount args depending upon provider type
         if args.serverURL is None and args.provider in [
             "aws",
             "generic-s3",
             "ontap-s3",
             "storagegrid-s3",
         ]:
@@ -102,23 +98,21 @@
         else:
             bucketParameters = {"s3": {"bucketName": args.bucketName, "serverURL": args.serverURL}}
         # Call manageBucket class
         rc = astraSDK.buckets.manageBucket(quiet=args.quiet, verbose=args.verbose).main(
             args.bucketName, args.credentialID, args.provider, bucketParameters
         )
         if rc is False:
-            print("astraSDK.buckets.manageBucket() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.buckets.manageBucket() failed")
     elif args.objectType == "cluster":
         rc = astraSDK.clusters.manageCluster(quiet=args.quiet, verbose=args.verbose).main(
             args.clusterID, args.defaultStorageClassID
         )
         if rc is False:
-            print("astraSDK.clusters.manageCluster() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.clusters.manageCluster() failed")
     elif args.objectType == "cloud":
         credentialID = None
         # First create the credential
         if args.cloudType != "private":
             if args.credentialPath is None:
                 parser.error(f"--credentialPath is required for cloudType of {args.cloudType}")
             with open(args.credentialPath, encoding="utf8") as f:
@@ -132,18 +126,17 @@
                 "service-account",
                 {"base64": encodedStr},
                 args.cloudType,
             )
             if rc:
                 credentialID = rc["id"]
             else:
-                print("astraSDK.credentials.createCredential() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Next manage the cloud
         rc = astraSDK.clouds.manageCloud(quiet=args.quiet, verbose=args.verbose).main(
             args.cloudName,
             args.cloudType,
             credentialID=credentialID,
             defaultBucketID=args.defaultBucketID,
         )
         if rc is False:
-            print("astraSDK.clouds.manageCloud() failed")
+            raise SystemExit("astraSDK.clouds.manageCloud() failed")
```

## tkSrc/parser.py

```diff
@@ -180,14 +180,18 @@
             "scripts",
             help="list scripts (hookSources)",
         )
         self.subparserListSnapshots = self.subparserList.add_parser(
             "snapshots",
             help="list snapshots",
         )
+        self.subparserListStorageBackends = self.subparserList.add_parser(
+            "storagebackends",
+            help="list storagebackends",
+        )
         self.subparserListStorageClasses = self.subparserList.add_parser(
             "storageclasses",
             help="list storageclasses",
         )
         self.subparserListUsers = self.subparserList.add_parser(
             "users",
             help="list users",
@@ -391,14 +395,21 @@
             "--multiNsMapping",
             required=False,
             default=None,
             action="append",
             nargs="*",
             help="For multi-namespace apps, specify matching number of sourcens1=destns1 mappings",
         )
+        self.parserClone.add_argument(
+            "--cloneStorageClass",
+            choices=(None if self.plaidMode else self.acl.storageClasses),
+            required=False,
+            default=None,
+            help="Optionally specify a different storage class for the clone",
+        )
         sourceGroup = self.parserClone.add_mutually_exclusive_group(required=True)
         sourceGroup.add_argument(
             "--backupID",
             choices=(None if self.plaidMode else self.acl.backups),
             required=False,
             default=None,
             help="Source backup to clone from",
@@ -552,15 +563,15 @@
 
     def list_clouds_args(self):
         """list clouds args and flags"""
         self.subparserListClouds.add_argument(
             "-t",
             "--cloudType",
             default=None,
-            choices=["GCP", "Azure", "AWS", "Private"],
+            choices=["GCP", "Azure", "AWS", "private"],
             help="Only show clouds of a single type",
         )
 
     def list_clusters_args(self):
         """list clusters args and flags"""
         self.subparserListClusters.add_argument(
             "-m",
@@ -709,17 +720,20 @@
 
     def list_storageclasses_args(self):
         """list storageclasses args and flags"""
         self.subparserListStorageClasses.add_argument(
             "-t",
             "--cloudType",
             default=None,
-            choices=["GCP", "Azure", "AWS", "Private"],
+            choices=["GCP", "Azure", "AWS", "private"],
             help="Only show storageclasses of a single cloud type",
         )
+        self.subparserListStorageClasses.add_argument(
+            "-c", "--cluster", default=None, help="Only show storageclasses from this cluster"
+        )
 
     def list_users_args(self):
         """list users args and flags"""
         self.subparserListUsers.add_argument(
             "-f",
             "--nameFilter",
             default=None,
@@ -776,14 +790,21 @@
             "-c",
             "--cloudID",
             choices=(None if self.plaidMode else self.acl.clouds),
             default=(self.acl.clouds[0] if len(self.acl.clouds) == 1 else None),
             required=(False if len(self.acl.clouds) == 1 else True),
             help="The cloudID to add the cluster to (only required if # of clouds > 1)",
         )
+        self.subparserCreateCluster.add_argument(
+            "--privateRouteID",
+            default=None,
+            required=False,
+            help="The private route identifier for private clusters "
+            "(can obtained from the Astra Connector)",
+        )
 
     def create_hook_args(self):
         """create hooks args and flags"""
         self.subparserCreateHook.add_argument(
             "appID",
             choices=(None if self.plaidMode else self.acl.apps),
             help="appID to create an execution hook for",
```

## tkSrc/restore.py

```diff
@@ -18,33 +18,32 @@
 import sys
 import time
 
 import astraSDK
 import tkSrc
 
 
-def exec(args, parser):
+def main(args, parser):
     if (args.filterSelection and not args.filterSet) or (
         args.filterSet and not args.filterSelection
     ):
-        parser.error(
-            f"either both or none of --filterSelection and --filterSet should be specified"
-        )
+        parser.error("either both or none of --filterSelection and --filterSet should be specified")
     rc = astraSDK.apps.restoreApp(quiet=args.quiet, verbose=args.verbose).main(
         args.appID,
         backupID=args.backupID,
         snapshotID=args.snapshotID,
         resourceFilter=tkSrc.helpers.createFilterSet(
             args.filterSelection, args.filterSet, astraSDK.apps.getAppAssets().main(args.appID)
         ),
     )
     if rc:
         if args.background:
             print("Restore job submitted successfully")
             print("Background restore flag selected, run 'list apps' to get status")
+            return True
         print("Restore job in progress...", end="")
         sys.stdout.flush()
         while True:
             restoreApps = astraSDK.apps.getApps().main()
             state = None
             for restoreApp in restoreApps["items"]:
                 if restoreApp["id"] == args.appID:
@@ -52,13 +51,11 @@
             if state == "restoring":
                 print(".", end="")
                 sys.stdout.flush()
             elif state == "ready":
                 print("Success!")
                 break
             elif state == "failed":
-                print("Failed!")
-                sys.exit(2)
+                raise SystemExit(f"Restore of app {args.appID} failed!")
             time.sleep(args.pollTimer)
     else:
-        print("Submitting restore job failed.")
-        sys.exit(3)
+        raise SystemExit("Submitting restore job failed.")
```

## tkSrc/unmanage.py

```diff
@@ -11,32 +11,28 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
-import sys
-
 import astraSDK
 
 
-def exec(args, ard):
+def main(args, ard):
     if args.objectType == "app":
         rc = astraSDK.apps.unmanageApp(quiet=args.quiet, verbose=args.verbose).main(args.appID)
         if rc is False:
-            print("astraSDK.apps.unmanageApp() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.apps.unmanageApp() failed")
     elif args.objectType == "bucket":
         rc = astraSDK.buckets.unmanageBucket(quiet=args.quiet, verbose=args.verbose).main(
             args.bucketID
         )
         if rc is False:
-            print("astraSDK.buckets.unmanageBucket() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.buckets.unmanageBucket() failed")
     elif args.objectType == "cluster":
         rc = astraSDK.clusters.unmanageCluster(quiet=args.quiet, verbose=args.verbose).main(
             args.clusterID
         )
         if rc:
             # "Private" cloud clusters+credentials also should be deleted
             if ard.needsattr("clusters"):
@@ -50,38 +46,33 @@
                     ):
                         if astraSDK.clusters.deleteCluster(
                             quiet=args.quiet, verbose=args.verbose
                         ).main(args.clusterID, cluster["cloudID"]):
                             if astraSDK.credentials.destroyCredential(
                                 quiet=args.quiet, verbose=args.verbose
                             ).main(cluster.get("credentialID")):
-                                print(f"Credential deleted")
+                                print("Credential deleted")
                             else:
-                                print("astraSDK.credentials.destroyCredential() failed")
-                                sys.exit(1)
+                                raise SystemExit("astraSDK.credentials.destroyCredential() failed")
                         else:
-                            print("astraSDK.clusters.deleteCluster() failed")
-                            sys.exit(1)
+                            raise SystemExit("astraSDK.clusters.deleteCluster() failed")
         else:
-            print("astraSDK.clusters.unmanageCluster() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.clusters.unmanageCluster() failed")
     elif args.objectType == "cloud":
         if ard.needsattr("cloud"):
             ard.clouds = astraSDK.clouds.getClouds().main()
         rc = astraSDK.clouds.unmanageCloud(quiet=args.quiet, verbose=args.verbose).main(
             args.cloudID
         )
         if rc:
             # Cloud credentials also should be deleted
             for cloud in ard.clouds["items"]:
                 if cloud["id"] == args.cloudID:
                     if cloud.get("credentialID"):
                         if astraSDK.credentials.destroyCredential(
                             quiet=args.quiet, verbose=args.verbose
                         ).main(cloud.get("credentialID")):
-                            print(f"Credential deleted")
+                            print("Credential deleted")
                         else:
-                            print("astraSDK.credentials.destroyCredential() failed")
-                            sys.exit(1)
+                            raise SystemExit("astraSDK.credentials.destroyCredential() failed")
         else:
-            print("astraSDK.clusters.unmanageCloud() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.clusters.unmanageCloud() failed")
```

## tkSrc/update.py

```diff
@@ -13,29 +13,28 @@
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import base64
 import json
-import sys
 import yaml
 
 
 import astraSDK
 
 
-def exec(args, parser, ard):
+def main(args, parser, ard):
     if args.objectType == "bucket":
         # Validate that both credentialID and accessKey/accessSecret were not specified
         if args.credentialID is not None and (
             args.accessKey is not None or args.accessSecret is not None
         ):
             parser.error(
-                f"if a credentialID is specified, neither accessKey nor accessSecret"
+                "if a credentialID is specified, neither accessKey nor accessSecret"
                 + " should be specified."
             )
         # Validate args and create credential if credentialID was not specified
         if args.credentialID is None:
             if args.accessKey is None or args.accessSecret is None:
                 parser.error(
                     "if a credentialID is not specified, both accessKey and "
@@ -55,23 +54,21 @@
                     cloudName="s3",
                 )
             except StopIteration:
                 parser.error(f"{args.bucketID} does not seem to be a valid bucketID")
             if crc:
                 args.credentialID = crc["id"]
             else:
-                print("astraSDK.credentials.createCredential() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Call updateBucket class
         rc = astraSDK.buckets.updateBucket(quiet=args.quiet, verbose=args.verbose).main(
             args.bucketID, credentialID=args.credentialID
         )
         if rc is False:
-            print("astraSDK.buckets.updateBucket() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.buckets.updateBucket() failed")
     elif args.objectType == "cloud":
         if args.credentialPath:
             with open(args.credentialPath, encoding="utf8") as f:
                 try:
                     credDict = json.loads(f.read().rstrip())
                 except json.decoder.JSONDecodeError:
                     parser.error(f"{args.credentialPath} does not seem to be valid JSON")
@@ -87,26 +84,23 @@
                 "service-account",
                 {"base64": encodedStr},
                 cloud["cloudType"],
             )
             if rc:
                 args.credentialID = rc["id"]
             else:
-                print("astraSDK.credentials.createCredential() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Next update the cloud
         rc = astraSDK.clouds.updateCloud(quiet=args.quiet, verbose=args.verbose).main(
             args.cloudID,
             credentialID=args.credentialID,
             defaultBucketID=args.defaultBucketID,
         )
         if rc is False:
-            print(rc.error)
-            print("astraSDK.clouds.updateCloud() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.clouds.updateCloud() failed")
     elif args.objectType == "cluster":
         # Get the cluster information based on the clusterID input
         if ard.needsattr("clusters"):
             ard.clusters = astraSDK.clusters.getClusters().main()
         try:
             cluster = next(c for c in ard.clusters["items"] if c["id"] == args.clusterID)
         except StopIteration:
@@ -120,16 +114,15 @@
                 )
             rc = astraSDK.credentials.updateCredential(quiet=args.quiet, verbose=args.verbose).main(
                 cluster.get("credentialID"),
                 kubeconfigDict["clusters"][0]["name"],
                 keyStore={"base64": encodedStr},
             )
             if rc is False:
-                print("astraSDK.credentials.updateCredential() failed")
-                sys.exit(1)
+                raise SystemExit("astraSDK.credentials.updateCredential() failed")
     elif args.objectType == "replication":
         # Gather replication data
         if ard.needsattr("replications"):
             ard.replications = astraSDK.replications.getReplicationpolicies().main()
             if not ard.replications:  # Gracefully handle ACS env
                 parser.error("'replication' commands are currently only supported in ACC.")
         repl = None
@@ -202,17 +195,16 @@
             rc = astraSDK.replications.updateReplicationpolicy(
                 quiet=args.quiet, verbose=args.verbose
             ).main(args.replicationID, "failedOver")
         # Exit based on response
         if rc:
             print(f"Replication {args.operation} initiated")
         else:
-            print("astraSDK.replications.updateReplicationpolicy() failed")
-            sys.exit(1)
+            raise SystemExit("astraSDK.replications.updateReplicationpolicy() failed")
     elif args.objectType == "script":
         with open(args.filePath, encoding="utf8") as f:
             encodedStr = base64.b64encode(f.read().rstrip().encode("utf-8")).decode("utf-8")
         rc = astraSDK.scripts.updateScript(quiet=args.quiet, verbose=args.verbose).main(
             args.scriptID, source=encodedStr
         )
         if rc is False:
-            print("astraSDK.scripts.updateScript() failed")
+            raise SystemExit("astraSDK.scripts.updateScript() failed")
```

## Comparing `actoolkit-2.6.6b1.dist-info/LICENSE` & `actoolkit-2.6.6b2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `actoolkit-2.6.6b1.dist-info/METADATA` & `actoolkit-2.6.6b2.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: actoolkit
-Version: 2.6.6b1
+Version: 2.6.6b2
 Summary: Toolkit and SDK for interacting with Astra Control
 Home-page: https://github.com/NetApp/netapp-astra-toolkits
 Author: Michael Haigh
 Author-email: Michael.Haigh@netapp.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
```

## Comparing `actoolkit-2.6.6b1.dist-info/RECORD` & `actoolkit-2.6.6b2.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-toolkit.py,sha256=Aojat8hKE5zFdp-j3mUckEKuFapvWKNg7pO6YbGFam4,20464
-astraSDK/__init__.py,sha256=yqW_2eujDPNcBYVkxfLo8Iyuz1tirB3-YvXJjXe7l8w,456
-astraSDK/apiresources.py,sha256=39Ri1uIQ8ZjQ55MNj8X1cyi6hwjv6Z1X1zbZMbvjFaw,3659
-astraSDK/apps.py,sha256=SsFvX2A1G9dhTRHj0sfY9qYfzKQbIcGVN5VxlmznqOI,16835
-astraSDK/backups.py,sha256=D7_8qWuVNgyvY0ujtjg84auwdhAaLwFn0H5D-LFscAc,8248
-astraSDK/buckets.py,sha256=-jb3PJxe1qNqVtyHquoYZODp0NfLCPdAgiKUHAM9fF8,7321
-astraSDK/clouds.py,sha256=d6J7Mae1GahU-Va6Kp9ltpC1RrAzVbAF93m6oOhx8Es,6972
-astraSDK/clusters.py,sha256=kYifg_AC8a3wPAQIFbspoVVH34q2rEYqHNqN0s_D9aY,9155
-astraSDK/common.py,sha256=aoQ0bljzzEjpQ1QI4FyQSRFMaCXHQb8gwOvbPE503w8,8083
-astraSDK/credentials.py,sha256=nC887tj5teE6aHSziAhoVDIhtRMYRB798rzSfOEPiUk,9115
-astraSDK/entitlements.py,sha256=ls-TXHRIMftLt9JqhI161lOzmhIlFjL3Ipdgc2uyJVk,2663
-astraSDK/hooks.py,sha256=WF2q1aUe39lpXsThA8d71TGUQqTI8Sbj7RHVkie-t8w,7162
-astraSDK/namespaces.py,sha256=SJxnwBJm_v-2YQEG0D1cyLd_jIuxRjLzmSVbEMyI7I0,5458
-astraSDK/notifications.py,sha256=k_UXBe_xvhc3VQAxEDRWEnC8iW4HzMHuIoD3hcp_duE,3511
-astraSDK/protections.py,sha256=powIWheo7J_ZDfxmzvYDCyrwso-RGtMDkchdUHiJsf4,8803
-astraSDK/replications.py,sha256=ozM2ORF1TPatyt4OyrULlqHj36tcGRlNXbypM8KqrpE,9735
-astraSDK/rolebindings.py,sha256=f6-mBO20EZKERSeKeL__ihBGan9sGIEHgTeVTmU80CQ,5758
-astraSDK/scripts.py,sha256=A-Rlx9dpVPnNnP4B4b_rGehRqHgKiNGAUb3ru25HrE0,7091
-astraSDK/snapshots.py,sha256=QQFOq7aMJ_ksxRUKwIvG4DKldmLiH7-7o05gqmaslGo,7035
-astraSDK/storagebackends.py,sha256=IUB1oRiyxojsmzCK0yR4xIwn3PKe_TBY4Jpszc34yyk,2342
-astraSDK/storageclasses.py,sha256=_1ikG_7QuPlKFFaV-aBBBxCXGQSogfnPhu1uLWUQ5zg,4726
-astraSDK/users.py,sha256=L-ODrGo6vpoOl3yxqzFjU9-gWqvDQhlFCvvGtoYN2YQ,4877
-tkSrc/__init__.py,sha256=sOP-1QmwLmAww75g1dq35rGzfCwhO3xnAe1Y-C5T0Zs,255
+toolkit.py,sha256=dnmw5Fme_R8DArzlQJfTK7wpbOB1ehOwNEYOrq9JGFk,21212
+astraSDK/__init__.py,sha256=g3FsSbjLdIcDbH2gcvC42vjAbcQucjzQJEZzkjGdmyo,1077
+astraSDK/apiresources.py,sha256=rz_8JYN0qeY4y1K5H6OzI1HQmhQMqRgcUogY1d9HJhs,3659
+astraSDK/apps.py,sha256=1ApPxCi4RUwuCDGlyRVXBdNntmqzM5MrymlQwmDTYlY,16991
+astraSDK/backups.py,sha256=5HbLo69lB_fO7meTTUTZGqfmh6a7VxIEOxfEtDgYv94,8248
+astraSDK/buckets.py,sha256=7tu3T1rZ2PR_k__RWsUxjNcY3WW0uH9Zp_ByjzAWY74,7321
+astraSDK/clouds.py,sha256=qcE1r0WbU3v3JSIF17Jlbsnv81kLE0M_uI8xFwqV5s0,6972
+astraSDK/clusters.py,sha256=pZ8nzcceWeRzhx5X9IJQos58w39FLTv6MCqMYFx1UKs,9255
+astraSDK/common.py,sha256=c8c-D6bTx2LB6hJ8Lm4o-0xkDTmhvdkrbA--w0dtyPA,8052
+astraSDK/credentials.py,sha256=tmvbJ9YwiqUhP0WKcSIysRYSB9gkCwXyVhYeKXB8xiA,9115
+astraSDK/entitlements.py,sha256=cWfWWEG-3i1aZbpKxD9adNaIcY50Ezm5Ykszu_sfp2A,2663
+astraSDK/hooks.py,sha256=cTpZOzRZD5OEqzInd4yUiJHj4JbLQ4tseMEAVVh9ef0,7162
+astraSDK/namespaces.py,sha256=NExkodJpRKHPbDlpAxcCcmp5vGaHV8JFrCXi02LQwFQ,5458
+astraSDK/notifications.py,sha256=bi_Ik8btt2aOcmYOIjRB7Uufyt8nVaIAFaZO9QUGJWc,3511
+astraSDK/protections.py,sha256=qQSqm-uFBbO6TReLH-8hC0e5ZRFSBLmuhYxK8EZVdRE,8803
+astraSDK/replications.py,sha256=1sFZtKDZ1k_0Y2f7V71ZZzoNP1vkR-3Xk8ESHB7j4gQ,9735
+astraSDK/rolebindings.py,sha256=C_fTyegWZ1XLaajIzI_ftybpkLEsPMnCmyn4mNn3g1M,5757
+astraSDK/scripts.py,sha256=AHMjcDhE5am8PhbUhALh7W22h2lSFe99qDRHTasGjtQ,7090
+astraSDK/snapshots.py,sha256=7WITgWHn6qvT6Pv4KttMrvoRnxs1NHUSOTiJMhw9Klg,7035
+astraSDK/storagebackends.py,sha256=U4xh-hv5P7ip69Je6e9HIqhGPusU0VukHmzugtUpk_o,2434
+astraSDK/storageclasses.py,sha256=YKMkLFqALreDcUPs1xQzzsadzLZPaLXmuwuJbKoMlXk,5023
+astraSDK/users.py,sha256=wVOVVVySv1HD5WsXXIY2q9Fa_hX9EMqQGDJpVOJgCBY,4877
+tkSrc/__init__.py,sha256=u2IQr5un_-EqXvv7X6n6OkwUoWRc9_XZwjatMvCriW8,846
 tkSrc/classes.py,sha256=IoNa_B3rXEdCsGgDNztB97f3bXto629_0UC8RNEqkLk,2634
-tkSrc/clone.py,sha256=RmUqrVZ1MF_bG0zSbdsOD2zRyOVhf1ZD31mIZAylaig,12587
-tkSrc/create.py,sha256=5IY00v-zpyyC1CsX13dGim2EKpgFUlzWnljBwHoyuCM,12203
-tkSrc/deploy.py,sha256=_Sin-EMsfW4UcFfOI7sgsuBoaGlOFT--w9IblpWJTak,6193
-tkSrc/destroy.py,sha256=khGMRLKTays1OxI79QigYPj68aE3UjrS8safNchp4V0,5461
-tkSrc/helpers.py,sha256=DWWOttPAAZvf12zRGEzaYTTqbsV0AN5YNwSW6mVvX7s,18774
-tkSrc/list.py,sha256=lj9_fGuSvwPFF0qwwycK-9e5MeVWS76Sk6S30BEDsAM,7300
-tkSrc/manage.py,sha256=mVxTJXqCTQTtfG9g1cO-flAH8NA-oY1Smn7QR6QU13A,6629
-tkSrc/parser.py,sha256=4SAl3D9zFSOUuOYGLh5X0D94omlBGmY9ObpaOjJjGCc,52332
-tkSrc/restore.py,sha256=1LEGvC5ecpqPATBLU-D3_hVnlDUvCqSECmtYMkxse1c,2193
-tkSrc/unmanage.py,sha256=MPp0T12BVr_VeKIpo4ZcdHt8gVKa7NfTpZjmAOzK4E4,3758
-tkSrc/update.py,sha256=CDNnweFnlsyjjEipEG2YZYhPb67WbMMpPvGbDrocR3A,10226
-actoolkit-2.6.6b1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-actoolkit-2.6.6b1.dist-info/METADATA,sha256=kOoSBcgqVIkMgRZao7IQjTFD2wHtPMqKYdwcdA-SbuA,9365
-actoolkit-2.6.6b1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-actoolkit-2.6.6b1.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
-actoolkit-2.6.6b1.dist-info/top_level.txt,sha256=kPzq0QmkpIhsU3ebVM66KWObD9yaaTEifDR30CUh3nU,42
-actoolkit-2.6.6b1.dist-info/RECORD,,
+tkSrc/clone.py,sha256=xuYbv5uoAUKIoaZKkyVjvTxcz_iIJ3yQbfJ24yCzyTQ,12685
+tkSrc/create.py,sha256=IpXBev6fLsTLkvKb7h-rwsBKWGc4vcfhAdVj7xhSi4U,12141
+tkSrc/deploy.py,sha256=RYc9lD4lk2ukQid53ET3XI5GXgaAsAan0QfzHDeqv3o,6206
+tkSrc/destroy.py,sha256=qmAEGXEIgzlN8LftoCPa6_lz0efJ57D2fvAv4KFeZbA,5453
+tkSrc/helpers.py,sha256=gjti-Q0DNW7-iG4eY0rK68y5sGPq2DGSEbrtSB9-V84,18584
+tkSrc/list.py,sha256=Kesag9b9JhpubdPYONDHHM4Wuhc0Nrb8IlU8BBgZ6gA,7370
+tkSrc/manage.py,sha256=9wBxUpzmpLec9hOmids774TyDUTe-lvRB9FoKxbyEC4,6527
+tkSrc/parser.py,sha256=AQlPgqStyAIcgGsiI9kxp1BpkfVDiQF7eVV6YNnkrAo,53212
+tkSrc/restore.py,sha256=o3CipQcArwB9V3croVyuM27b2qJHGpb77U60OUQRg6k,2197
+tkSrc/unmanage.py,sha256=g5V_Ilcsf--mIghZmOY9O_kuU2vNVFJnQP1s77AlcHg,3601
+tkSrc/update.py,sha256=uVnY7mK8x3z0ovLeEnWwgluOCJsnOnVvTZXx0LA2G1w,10107
+actoolkit-2.6.6b2.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+actoolkit-2.6.6b2.dist-info/METADATA,sha256=zqCGtixc4ldS2eL4ifYitIwhZuXvHqV4bCt3bRw_Wh0,9365
+actoolkit-2.6.6b2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+actoolkit-2.6.6b2.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
+actoolkit-2.6.6b2.dist-info/top_level.txt,sha256=kPzq0QmkpIhsU3ebVM66KWObD9yaaTEifDR30CUh3nU,42
+actoolkit-2.6.6b2.dist-info/RECORD,,
```

