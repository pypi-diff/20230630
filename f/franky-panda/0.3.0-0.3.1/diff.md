# Comparing `tmp/franky_panda-0.3.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/franky_panda-0.3.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,22 @@
-Zip file size: 2304540 bytes, number of entries: 20
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-30 13:37 franky_panda.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-30 13:37 franky/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-30 13:37 franky_panda-0.3.0.dist-info/
--rwxr-xr-x  2.0 unx  5650561 b- defN 23-Jun-30 13:37 franky_panda.libs/libfranka-44262da5.so.0.9.0
--rwxr-xr-x  2.0 unx  1615409 b- defN 23-Jun-30 13:37 franky_panda.libs/libPocoNet-ac8eb170.so.31
--rwxr-xr-x  2.0 unx   406817 b- defN 23-Jun-30 13:37 franky_panda.libs/libpcre-9513aab5.so.1.2.0
--rwxr-xr-x  2.0 unx  2252345 b- defN 23-Jun-30 13:37 franky_panda.libs/libPocoFoundation-c26869a6.so.31
--rw-r--r--  2.0 unx      404 b- defN 23-Jun-30 13:37 franky/gripper.py
--rw-r--r--  2.0 unx     1329 b- defN 23-Jun-30 13:37 franky/__init__.py
--rw-r--r--  2.0 unx      272 b- defN 23-Jun-30 13:37 franky/motion.py
--rw-r--r--  2.0 unx      234 b- defN 23-Jun-30 13:37 franky/robot.py
--rw-r--r--  2.0 unx    40169 b- defN 23-Jun-30 13:37 franky/_franky.pyi
--rwxr-xr-x  2.0 unx  1567009 b- defN 23-Jun-30 13:37 franky/_franky.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx     1448 b- defN 23-Jun-30 13:37 franky/reaction.py
--rw-r--r--  2.0 unx     2198 b- defN 23-Jun-30 13:37 franky/robot_web_session.py
--rw-r--r--  2.0 unx    18732 b- defN 23-Jun-30 13:37 franky_panda-0.3.0.dist-info/METADATA
--rw-r--r--  2.0 unx     7650 b- defN 23-Jun-30 13:37 franky_panda-0.3.0.dist-info/LICENSE
--rw-r--r--  2.0 unx       22 b- defN 23-Jun-30 13:37 franky_panda-0.3.0.dist-info/top_level.txt
--rw-r--r--  2.0 unx      148 b- defN 23-Jun-30 13:37 franky_panda-0.3.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx     1481 b- defN 23-Jun-30 13:37 franky_panda-0.3.0.dist-info/RECORD
-20 files, 11566228 bytes uncompressed, 2301812 bytes compressed:  80.1%
+Zip file size: 2304582 bytes, number of entries: 20
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-30 14:38 franky_panda.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-30 14:38 franky/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-30 14:38 franky_panda-0.3.1.dist-info/
+-rwxr-xr-x  2.0 unx  5650561 b- defN 23-Jun-30 14:38 franky_panda.libs/libfranka-44262da5.so.0.9.0
+-rwxr-xr-x  2.0 unx  1615409 b- defN 23-Jun-30 14:38 franky_panda.libs/libPocoNet-ac8eb170.so.31
+-rwxr-xr-x  2.0 unx   406817 b- defN 23-Jun-30 14:38 franky_panda.libs/libpcre-9513aab5.so.1.2.0
+-rwxr-xr-x  2.0 unx  2252345 b- defN 23-Jun-30 14:38 franky_panda.libs/libPocoFoundation-c26869a6.so.31
+-rw-r--r--  2.0 unx      404 b- defN 23-Jun-30 14:38 franky/gripper.py
+-rw-r--r--  2.0 unx     1329 b- defN 23-Jun-30 14:38 franky/__init__.py
+-rw-r--r--  2.0 unx      272 b- defN 23-Jun-30 14:38 franky/motion.py
+-rw-r--r--  2.0 unx      234 b- defN 23-Jun-30 14:38 franky/robot.py
+-rw-r--r--  2.0 unx    41384 b- defN 23-Jun-30 14:38 franky/_franky.pyi
+-rwxr-xr-x  2.0 unx  1567009 b- defN 23-Jun-30 14:38 franky/_franky.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     1448 b- defN 23-Jun-30 14:38 franky/reaction.py
+-rw-r--r--  2.0 unx     2198 b- defN 23-Jun-30 14:38 franky/robot_web_session.py
+-rw-r--r--  2.0 unx    18762 b- defN 23-Jun-30 14:38 franky_panda-0.3.1.dist-info/METADATA
+-rw-r--r--  2.0 unx     7650 b- defN 23-Jun-30 14:38 franky_panda-0.3.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-30 14:38 franky_panda-0.3.1.dist-info/top_level.txt
+-rw-r--r--  2.0 unx      148 b- defN 23-Jun-30 14:38 franky_panda-0.3.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx     1481 b- defN 23-Jun-30 14:38 franky_panda-0.3.1.dist-info/RECORD
+20 files, 11567473 bytes uncompressed, 2301854 bytes compressed:  80.1%
```

## zipnote {}

```diff
@@ -1,14 +1,14 @@
 Filename: franky_panda.libs/
 Comment: 
 
 Filename: franky/
 Comment: 
 
-Filename: franky_panda-0.3.0.dist-info/
+Filename: franky_panda-0.3.1.dist-info/
 Comment: 
 
 Filename: franky_panda.libs/libfranka-44262da5.so.0.9.0
 Comment: 
 
 Filename: franky_panda.libs/libPocoNet-ac8eb170.so.31
 Comment: 
@@ -39,23 +39,23 @@
 
 Filename: franky/reaction.py
 Comment: 
 
 Filename: franky/robot_web_session.py
 Comment: 
 
-Filename: franky_panda-0.3.0.dist-info/METADATA
+Filename: franky_panda-0.3.1.dist-info/METADATA
 Comment: 
 
-Filename: franky_panda-0.3.0.dist-info/LICENSE
+Filename: franky_panda-0.3.1.dist-info/LICENSE
 Comment: 
 
-Filename: franky_panda-0.3.0.dist-info/top_level.txt
+Filename: franky_panda-0.3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: franky_panda-0.3.0.dist-info/WHEEL
+Filename: franky_panda-0.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: franky_panda-0.3.0.dist-info/RECORD
+Filename: franky_panda-0.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## franky/_franky.pyi

```diff
@@ -110,15 +110,15 @@
     @property
     def reactions(self) -> typing.List[CartesianPoseReaction]:
         """
         :type: typing.List[CartesianPoseReaction]
         """
     pass
 class CartesianPoseReaction():
-    def __init__(self, condition: Condition, motion: CartesianPoseMotion = None) -> None: ...
+    def __init__(self, condition: typing.Union[Condition, bool], motion: CartesianPoseMotion = None) -> None: ...
     def register_callback(self, callback: typing.Callable[[RobotState, float, float], None]) -> None: ...
     pass
 class CartesianPoseStopMotion(CartesianPoseMotion):
     def __init__(self) -> None: ...
     pass
 class CartesianVelocities():
     @property
@@ -133,67 +133,67 @@
     @property
     def reactions(self) -> typing.List[CartesianVelocityReaction]:
         """
         :type: typing.List[CartesianVelocityReaction]
         """
     pass
 class CartesianVelocityReaction():
-    def __init__(self, condition: Condition, motion: CartesianVelocityMotion = None) -> None: ...
+    def __init__(self, condition: typing.Union[Condition, bool], motion: CartesianVelocityMotion = None) -> None: ...
     def register_callback(self, callback: typing.Callable[[RobotState, float, float], None]) -> None: ...
     pass
 class CartesianWaypoint():
-    def __init__(self, robot_pose: RobotPose, reference_type: ReferenceType = ReferenceType.Absolute, relative_dynamics_factor: RelativeDynamicsFactor = 1.0, minimum_time: typing.Optional[float] = None) -> None: ...
+    def __init__(self, robot_pose: typing.Union[RobotPose, Affine], reference_type: ReferenceType = ReferenceType.Absolute, relative_dynamics_factor: typing.Union[RelativeDynamicsFactor, float] = 1.0, minimum_time: typing.Optional[float] = None) -> None: ...
     @property
     def minimum_time(self) -> typing.Optional[float]:
         """
         :type: typing.Optional[float]
         """
     @property
     def reference_type(self) -> ReferenceType:
         """
         :type: ReferenceType
         """
     @property
-    def relative_dynamics_factor(self) -> RelativeDynamicsFactor:
+    def relative_dynamics_factor(self) -> typing.Union[RelativeDynamicsFactor, float]:
         """
-        :type: RelativeDynamicsFactor
+        :type: typing.Union[RelativeDynamicsFactor, float]
         """
     @property
-    def target(self) -> RobotPose:
+    def target(self) -> typing.Union[RobotPose, Affine]:
         """
-        :type: RobotPose
+        :type: typing.Union[RobotPose, Affine]
         """
     pass
 class CartesianWaypointMotion(CartesianPoseMotion):
-    def __init__(self, waypoints: typing.List[CartesianWaypoint], frame: typing.Optional[Affine] = None, relative_dynamics_factor: RelativeDynamicsFactor = 1.0, return_when_finished: bool = True) -> None: ...
+    def __init__(self, waypoints: typing.List[CartesianWaypoint], frame: typing.Optional[Affine] = None, relative_dynamics_factor: typing.Union[RelativeDynamicsFactor, float] = 1.0, return_when_finished: bool = True) -> None: ...
     pass
 class CommandException(Exception, BaseException):
     pass
 class Condition():
     @typing.overload
-    def __and__(self, arg0: Condition) -> Condition: ...
+    def __and__(self, arg0: typing.Union[Condition, bool]) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __and__(self, arg0: bool) -> Condition: ...
+    def __and__(self, arg0: bool) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __eq__(self, arg0: Condition) -> Condition: ...
+    def __eq__(self, arg0: typing.Union[Condition, bool]) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __eq__(self, arg0: bool) -> Condition: ...
+    def __eq__(self, arg0: bool) -> typing.Union[Condition, bool]: ...
     def __init__(self, constant_value: bool) -> None: ...
-    def __invert__(self) -> Condition: ...
+    def __invert__(self) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __ne__(self, arg0: Condition) -> Condition: ...
+    def __ne__(self, arg0: typing.Union[Condition, bool]) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __ne__(self, arg0: bool) -> Condition: ...
+    def __ne__(self, arg0: bool) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __or__(self, arg0: Condition) -> Condition: ...
+    def __or__(self, arg0: typing.Union[Condition, bool]) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __or__(self, arg0: bool) -> Condition: ...
-    def __rand__(self, arg0: Condition) -> Condition: ...
+    def __or__(self, arg0: bool) -> typing.Union[Condition, bool]: ...
+    def __rand__(self, arg0: typing.Union[Condition, bool]) -> typing.Union[Condition, bool]: ...
     def __repr__(self) -> str: ...
-    def __ror__(self, arg0: Condition) -> Condition: ...
+    def __ror__(self, arg0: typing.Union[Condition, bool]) -> typing.Union[Condition, bool]: ...
     __hash__ = None
     pass
 class ControlException(Exception, BaseException):
     pass
 class ControlSignalType():
     """
     Members:
@@ -577,15 +577,15 @@
     @property
     def reactions(self) -> typing.List[JointPositionReaction]:
         """
         :type: typing.List[JointPositionReaction]
         """
     pass
 class JointPositionReaction():
-    def __init__(self, condition: Condition, motion: JointPositionMotion = None) -> None: ...
+    def __init__(self, condition: typing.Union[Condition, bool], motion: JointPositionMotion = None) -> None: ...
     def register_callback(self, callback: typing.Callable[[RobotState, float, float], None]) -> None: ...
     pass
 class JointPositionStopMotion(JointPositionMotion):
     def __init__(self) -> None: ...
     pass
 class JointPositions():
     @property
@@ -607,42 +607,42 @@
     @property
     def reactions(self) -> typing.List[JointVelocityReaction]:
         """
         :type: typing.List[JointVelocityReaction]
         """
     pass
 class JointVelocityReaction():
-    def __init__(self, condition: Condition, motion: JointVelocityMotion = None) -> None: ...
+    def __init__(self, condition: typing.Union[Condition, bool], motion: JointVelocityMotion = None) -> None: ...
     def register_callback(self, callback: typing.Callable[[RobotState, float, float], None]) -> None: ...
     pass
 class JointWaypoint():
-    def __init__(self, target: numpy.ndarray[numpy.float64, _Shape[7, 1]], reference_type: ReferenceType = ReferenceType.Absolute, relative_dynamics_factor: RelativeDynamicsFactor = 1.0, minimum_time: typing.Optional[float] = None) -> None: ...
+    def __init__(self, target: numpy.ndarray[numpy.float64, _Shape[7, 1]], reference_type: ReferenceType = ReferenceType.Absolute, relative_dynamics_factor: typing.Union[RelativeDynamicsFactor, float] = 1.0, minimum_time: typing.Optional[float] = None) -> None: ...
     @property
     def minimum_time(self) -> typing.Optional[float]:
         """
         :type: typing.Optional[float]
         """
     @property
     def reference_type(self) -> ReferenceType:
         """
         :type: ReferenceType
         """
     @property
-    def relative_dynamics_factor(self) -> RelativeDynamicsFactor:
+    def relative_dynamics_factor(self) -> typing.Union[RelativeDynamicsFactor, float]:
         """
-        :type: RelativeDynamicsFactor
+        :type: typing.Union[RelativeDynamicsFactor, float]
         """
     @property
     def target(self) -> numpy.ndarray[numpy.float64, _Shape[7, 1]]:
         """
         :type: numpy.ndarray[numpy.float64, _Shape[7, 1]]
         """
     pass
 class JointWaypointMotion(JointPositionMotion):
-    def __init__(self, waypoints: typing.List[JointWaypoint], relative_dynamics_factor: RelativeDynamicsFactor = 1.0, return_when_finished: bool = True) -> None: ...
+    def __init__(self, waypoints: typing.List[JointWaypoint], relative_dynamics_factor: typing.Union[RelativeDynamicsFactor, float] = 1.0, return_when_finished: bool = True) -> None: ...
     pass
 class Kinematics():
     @staticmethod
     def forward(q: numpy.ndarray[numpy.float64, _Shape[7, 1]]) -> Affine: ...
     @staticmethod
     def forward_elbow(q: numpy.ndarray[numpy.float64, _Shape[7, 1]]) -> Affine: ...
     @staticmethod
@@ -652,49 +652,49 @@
     @staticmethod
     def jacobian(q: numpy.ndarray[numpy.float64, _Shape[7, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 7]]: ...
     pass
 class LinearImpedanceMotion(ImpedanceMotion, TorqueMotion):
     def __init__(self, target: Affine, duration: float, target_type: ReferenceType = ReferenceType.Absolute, translational_stiffness: float = 2000, rotational_stiffness: float = 200, force_constraints: typing.Optional[typing.List[typing.Optional[float][6]]] = None, return_when_finished: bool = True, finish_wait_factor: float = 1.2) -> None: ...
     pass
 class LinearMotion(CartesianWaypointMotion, CartesianPoseMotion):
-    def __init__(self, target: RobotPose, reference_type: ReferenceType = ReferenceType.Absolute, frame: typing.Optional[Affine] = None, relative_dynamics_factor: RelativeDynamicsFactor = 1.0, return_when_finished: bool = True) -> None: ...
+    def __init__(self, target: typing.Union[RobotPose, Affine], reference_type: ReferenceType = ReferenceType.Absolute, frame: typing.Optional[Affine] = None, relative_dynamics_factor: typing.Union[RelativeDynamicsFactor, float] = 1.0, return_when_finished: bool = True) -> None: ...
     pass
 class Measure():
     @typing.overload
     def __add__(self, arg0: Measure) -> Measure: ...
     @typing.overload
     def __add__(self, arg0: float) -> Measure: ...
     @typing.overload
-    def __eq__(self, arg0: Measure) -> Condition: ...
+    def __eq__(self, arg0: Measure) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __eq__(self, arg0: float) -> Condition: ...
+    def __eq__(self, arg0: float) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __ge__(self, arg0: Measure) -> Condition: ...
+    def __ge__(self, arg0: Measure) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __ge__(self, arg0: float) -> Condition: ...
+    def __ge__(self, arg0: float) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __gt__(self, arg0: Measure) -> Condition: ...
+    def __gt__(self, arg0: Measure) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __gt__(self, arg0: float) -> Condition: ...
+    def __gt__(self, arg0: float) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __le__(self, arg0: Measure) -> Condition: ...
+    def __le__(self, arg0: Measure) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __le__(self, arg0: float) -> Condition: ...
+    def __le__(self, arg0: float) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __lt__(self, arg0: Measure) -> Condition: ...
+    def __lt__(self, arg0: Measure) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __lt__(self, arg0: float) -> Condition: ...
+    def __lt__(self, arg0: float) -> typing.Union[Condition, bool]: ...
     @typing.overload
     def __mul__(self, arg0: Measure) -> Measure: ...
     @typing.overload
     def __mul__(self, arg0: float) -> Measure: ...
     @typing.overload
-    def __ne__(self, arg0: Measure) -> Condition: ...
+    def __ne__(self, arg0: Measure) -> typing.Union[Condition, bool]: ...
     @typing.overload
-    def __ne__(self, arg0: float) -> Condition: ...
+    def __ne__(self, arg0: float) -> typing.Union[Condition, bool]: ...
     def __neg__(self) -> Measure: ...
     @typing.overload
     def __pow__(self, arg0: Measure) -> Measure: ...
     @typing.overload
     def __pow__(self, arg0: float) -> Measure: ...
     def __radd__(self, arg0: float) -> Measure: ...
     def __repr__(self) -> str: ...
@@ -811,15 +811,15 @@
 class RelativeDynamicsFactor():
     @typing.overload
     def __init__(self) -> None: ...
     @typing.overload
     def __init__(self, arg0: float) -> None: ...
     @typing.overload
     def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
-    def __mul__(self, arg0: RelativeDynamicsFactor) -> RelativeDynamicsFactor: ...
+    def __mul__(self, arg0: typing.Union[RelativeDynamicsFactor, float]) -> typing.Union[RelativeDynamicsFactor, float]: ...
     @property
     def acceleration(self) -> float:
         """
         :type: float
         """
     @property
     def jerk(self) -> float:
@@ -835,15 +835,15 @@
     def velocity(self) -> float:
         """
         :type: float
         """
     MAX_DYNAMICS: _franky.RelativeDynamicsFactor
     pass
 class RobotInternal():
-    def __init__(self, fci_hostname: str, relative_dynamics_factor: RelativeDynamicsFactor = 1.0, default_torque_threshold: float = 20.0, default_force_threshold: float = 30.0, controller_mode: ControllerMode = ControllerMode.JointImpedance, realtime_config: RealtimeConfig = RealtimeConfig.Enforce) -> None: ...
+    def __init__(self, fci_hostname: str, relative_dynamics_factor: typing.Union[RelativeDynamicsFactor, float] = 1.0, default_torque_threshold: float = 20.0, default_force_threshold: float = 30.0, controller_mode: ControllerMode = ControllerMode.JointImpedance, realtime_config: RealtimeConfig = RealtimeConfig.Enforce) -> None: ...
     @staticmethod
     def forward_kinematics(q: numpy.ndarray[numpy.float64, _Shape[7, 1]]) -> Affine: ...
     @staticmethod
     def inverseKinematics(target: Affine, q0: numpy.ndarray[numpy.float64, _Shape[7, 1]]) -> numpy.ndarray[numpy.float64, _Shape[7, 1]]: ...
     def join_motion(self) -> None: ...
     @typing.overload
     def move(self, motion: CartesianPoseMotion, asynchronous: bool = False) -> None: ...
@@ -876,17 +876,17 @@
         """
     @property
     def current_joint_positions(self) -> numpy.ndarray[numpy.float64, _Shape[7, 1]]:
         """
         :type: numpy.ndarray[numpy.float64, _Shape[7, 1]]
         """
     @property
-    def current_pose(self) -> RobotPose:
+    def current_pose(self) -> typing.Union[RobotPose, Affine]:
         """
-        :type: RobotPose
+        :type: typing.Union[RobotPose, Affine]
         """
     @property
     def fci_hostname(self) -> str:
         """
         :type: str
         """
     @property
@@ -896,20 +896,20 @@
         """
     @property
     def is_in_control(self) -> bool:
         """
         :type: bool
         """
     @property
-    def relative_dynamics_factor(self) -> RelativeDynamicsFactor:
+    def relative_dynamics_factor(self) -> typing.Union[RelativeDynamicsFactor, float]:
         """
-        :type: RelativeDynamicsFactor
+        :type: typing.Union[RelativeDynamicsFactor, float]
         """
     @relative_dynamics_factor.setter
-    def relative_dynamics_factor(self, arg1: RelativeDynamicsFactor) -> None:
+    def relative_dynamics_factor(self, arg1: typing.Union[RelativeDynamicsFactor, float]) -> None:
         pass
     @property
     def state(self) -> RobotState:
         """
         :type: RobotState
         """
     control_rate = 0.001
@@ -973,19 +973,19 @@
     UserStopped: _franky.RobotMode # value = <RobotMode.UserStopped: 5>
     __members__: dict # value = {'Other': <RobotMode.Other: 0>, 'Idle': <RobotMode.Idle: 1>, 'Move': <RobotMode.Move: 2>, 'Guiding': <RobotMode.Guiding: 3>, 'Reflex': <RobotMode.Reflex: 4>, 'UserStopped': <RobotMode.UserStopped: 5>, 'AutomaticErrorRecovery': <RobotMode.AutomaticErrorRecovery: 6>}
     pass
 class RobotPose():
     @typing.overload
     def __init__(self, end_effector_pose: Affine, elbow_position: typing.Optional[float] = None) -> None: ...
     @typing.overload
-    def __init__(self, arg0: RobotPose) -> None: ...
-    def __mul__(self, arg0: Affine) -> RobotPose: ...
+    def __init__(self, arg0: typing.Union[RobotPose, Affine]) -> None: ...
+    def __mul__(self, arg0: Affine) -> typing.Union[RobotPose, Affine]: ...
     def __repr__(self) -> str: ...
-    def __rmul__(self, arg0: Affine) -> RobotPose: ...
-    def with_elbow_position(self, elbow_position: typing.Optional[float]) -> RobotPose: ...
+    def __rmul__(self, arg0: Affine) -> typing.Union[RobotPose, Affine]: ...
+    def with_elbow_position(self, elbow_position: typing.Optional[float]) -> typing.Union[RobotPose, Affine]: ...
     @property
     def elbow_position(self) -> typing.Optional[float]:
         """
         :type: typing.Optional[float]
         """
     @property
     def end_effector_pose(self) -> Affine:
@@ -1210,15 +1210,15 @@
         :type: Duration
         """
     pass
 class ExponentialImpedanceMotion(ImpedanceMotion, TorqueMotion):
     def __init__(self, target: Affine, target_type: ReferenceType = ReferenceType.Absolute, translational_stiffness: float = 2000, rotational_stiffness: float = 200, force_constraints: typing.Optional[typing.List[typing.Optional[float][6]]] = None, exponential_decay: float = 0.005) -> None: ...
     pass
 class TorqueReaction():
-    def __init__(self, condition: Condition, motion: TorqueMotion = None) -> None: ...
+    def __init__(self, condition: typing.Union[Condition, bool], motion: TorqueMotion = None) -> None: ...
     def register_callback(self, callback: typing.Callable[[RobotState, float, float], None]) -> None: ...
     pass
 class Torques():
     @property
     def tau_J(self) -> typing.List[float[7]]:
         """
         :type: typing.List[float[7]]
```

## Comparing `franky_panda-0.3.0.dist-info/METADATA` & `franky_panda-0.3.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: franky-panda
-Version: 0.3.0
+Version: 0.3.1
 Summary: High-Level Motion Library for the Franka Panda Robot (fork of frankx)
 Home-page: https://github.com/TimSchneider42/franky
 Author: Tim Schneider
 Author-email: tim@robot-learning.de
 License: LGPL
 Keywords: robot,robotics,trajectory-generation,motion-control
 Classifier: Development Status :: 4 - Beta
@@ -137,15 +137,15 @@
 ```
 
 The corresponding program in Python is
 ```python
 from franky import Affine, LinearMotion, Robot, ReferenceType
 
 robot = Robot("172.16.0.2")
-robot.set_dynamic_rel(0.05)
+robot.relative_dynamics_factor = 0.05
 
 motion = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)
 robot.move(motion)
 ```
 
 Furthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.
 
@@ -180,15 +180,15 @@
 
 robot = Robot("172.16.0.2")
 
 # Recover from errors
 robot.recover_from_errors()
 
 # Set velocity, acceleration and jerk to 5% of the maximum
-robot.set_dynamic_rel(0.05)
+robot.relative_dynamics_factor = 0.05
 
 # Alternatively, you can define each constraint individually
 robot.velocity_rel = 0.2
 robot.acceleration_rel = 0.1
 robot.jerk_rel = 0.01
 
 # Get the current pose
@@ -366,15 +366,15 @@
 By setting the `asynchronous` parameter of `Robot.move` to `True`, the function does not block until the motion finishes.
 Instead, it returns immediately and, thus, allows the main thread to set new motions asynchronously. 
 ```python
 import time
 from franky import Affine, LinearMotion, Robot, ReferenceType
 
 robot = Robot("172.16.0.2")
-robot.set_dynamic_rel(0.05)
+robot.relative_dynamics_factor = 0.05
 
 motion1 = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)
 robot.move(motion1, asynchronous=True)
 
 time.sleep(0.5)
 motion2 = LinearMotion(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative)
 robot.move(motion2, asynchronous=True)
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: franky-panda Version: 0.3.0 Summary: High-Level
+Metadata-Version: 2.1 Name: franky-panda Version: 0.3.1 Summary: High-Level
 Motion Library for the Franka Panda Robot (fork of frankx) Home-page: https://
 github.com/TimSchneider42/franky Author: Tim Schneider Author-email: tim@robot-
 learning.de License: LGPL Keywords: robot,robotics,trajectory-
 generation,motion-control Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research Classifier: Topic ::
 Scientific/Engineering Classifier: License :: OSI Approved :: GNU Lesser
 General Public License v3 (LGPLv3) Classifier: Programming Language :: C++
@@ -67,34 +67,35 @@
 ranky.hpp> using namespace franky; // Connect to the robot with the FCI IP
 address Robot robot("172.16.0.2"); // Reduce velocity and acceleration of the
 robot robot.setDynamicRel(0.05); // Move the end-effector 20cm in positive x-
 direction auto motion = LinearMotion(RobotPose(Affine({0.2, 0.0, 0.0}), 0.0),
 ReferenceType::Relative); // Finally move the robot robot.move(motion); ``` The
 corresponding program in Python is ```python from franky import Affine,
 LinearMotion, Robot, ReferenceType robot = Robot("172.16.0.2")
-robot.set_dynamic_rel(0.05) motion = LinearMotion(Affine([0.2, 0.0, 0.0]),
-ReferenceType.Relative) robot.move(motion) ``` Furthermore, we will introduce
-methods for geometric calculations, for moving the robot according to different
-motion types, how to implement real-time reactions and changing waypoints in
-real time as well as controlling the gripper. ### Geometry `franky.Affine` is a
-python wrapper for [Eigen::Affine3d](https://eigen.tuxfamily.org/dox/
-group__TutorialGeometry.html). It is used for Cartesian poses, frames and
-transformation. franky adds its own constructor, which takes a position and a
-quaternion as inputs: ```python import math from scipy.spatial.transform import
-Rotation from franky import Affine z_translation = Affine([0.0, 0.0, 0.5]) quat
-= Rotation.from_euler("xyz", [0, 0, math.pi / 2]).as_quat() z_rotation = Affine
-([0.0, 0.0, 0.0], quat) combined_transformation = z_translation * z_rotation
-``` In all cases, distances are in [m] and rotations in [rad]. ### Robot We
-wrapped most of the libfanka API (including the RobotState or ErrorMessage) for
-Python. Moreover, we added methods to adapt the dynamics of the robot for all
-motions. The `rel` name denotes that this a factor of the maximum constraints
-of the robot. ```python from franky import Robot robot = Robot("172.16.0.2") #
-Recover from errors robot.recover_from_errors() # Set velocity, acceleration
-and jerk to 5% of the maximum robot.set_dynamic_rel(0.05) # Alternatively, you
-can define each constraint individually robot.velocity_rel = 0.2
+robot.relative_dynamics_factor = 0.05 motion = LinearMotion(Affine([0.2, 0.0,
+0.0]), ReferenceType.Relative) robot.move(motion) ``` Furthermore, we will
+introduce methods for geometric calculations, for moving the robot according to
+different motion types, how to implement real-time reactions and changing
+waypoints in real time as well as controlling the gripper. ### Geometry
+`franky.Affine` is a python wrapper for [Eigen::Affine3d](https://
+eigen.tuxfamily.org/dox/group__TutorialGeometry.html). It is used for Cartesian
+poses, frames and transformation. franky adds its own constructor, which takes
+a position and a quaternion as inputs: ```python import math from
+scipy.spatial.transform import Rotation from franky import Affine z_translation
+= Affine([0.0, 0.0, 0.5]) quat = Rotation.from_euler("xyz", [0, 0, math.pi /
+2]).as_quat() z_rotation = Affine([0.0, 0.0, 0.0], quat)
+combined_transformation = z_translation * z_rotation ``` In all cases,
+distances are in [m] and rotations in [rad]. ### Robot We wrapped most of the
+libfanka API (including the RobotState or ErrorMessage) for Python. Moreover,
+we added methods to adapt the dynamics of the robot for all motions. The `rel`
+name denotes that this a factor of the maximum constraints of the robot.
+```python from franky import Robot robot = Robot("172.16.0.2") # Recover from
+errors robot.recover_from_errors() # Set velocity, acceleration and jerk to 5%
+of the maximum robot.relative_dynamics_factor = 0.05 # Alternatively, you can
+define each constraint individually robot.velocity_rel = 0.2
 robot.acceleration_rel = 0.1 robot.jerk_rel = 0.01 # Get the current pose
 current_pose = robot.current_pose ``` ### Robot State The robot state can be
 retrieved by calling the following methods: * `state`: Return an object of the
 `franky.RobotState` class which contains most of the same attributes, under the
 same name, as the libfranka [franka::RobotState](https://frankaemika.github.io/
 libfranka/structfranka_1_1RobotState.html) definition. * `current_pose`: Return
 a 3D Affine transformation object of the measured end effector pose in base
@@ -186,20 +187,20 @@
 motion generator // (we are just returning a stop motion, but there could be
 arbitrary // logic here for generating reaction motions) return StopMotion();
 }) )); robot.move(motion) ``` ### Real-Time Motion By setting the
 `asynchronous` parameter of `Robot.move` to `True`, the function does not block
 until the motion finishes. Instead, it returns immediately and, thus, allows
 the main thread to set new motions asynchronously. ```python import time from
 franky import Affine, LinearMotion, Robot, ReferenceType robot = Robot
-("172.16.0.2") robot.set_dynamic_rel(0.05) motion1 = LinearMotion(Affine([0.2,
-0.0, 0.0]), ReferenceType.Relative) robot.move(motion1, asynchronous=True)
-time.sleep(0.5) motion2 = LinearMotion(Affine([0.2, 0.0, 0.0]),
-ReferenceType.Relative) robot.move(motion2, asynchronous=True) ``` By calling
-`Robot.join_motion` the main thread can be synchronized with the motion thread,
-as it will block until the robot finishes its motion. ```python
+("172.16.0.2") robot.relative_dynamics_factor = 0.05 motion1 = LinearMotion
+(Affine([0.2, 0.0, 0.0]), ReferenceType.Relative) robot.move(motion1,
+asynchronous=True) time.sleep(0.5) motion2 = LinearMotion(Affine([0.2, 0.0,
+0.0]), ReferenceType.Relative) robot.move(motion2, asynchronous=True) ``` By
+calling `Robot.join_motion` the main thread can be synchronized with the motion
+thread, as it will block until the robot finishes its motion. ```python
 robot.join_motion() ``` Note that when exceptions occur during the asynchronous
 execution of a motion, they will not be thrown immediately. Instead, the
 control thread stores the exception and terminates. The next time
 `Robot.join_motion` or `Robot.move` are called, they will throw the stored
 exception in the main thread. Hence, after an asynchronous motion has finished,
 make sure to call `Robot.join_motion` to ensure being notified of any
 exceptions that occurred during the motion. ### Gripper In the `franky::
```

## Comparing `franky_panda-0.3.0.dist-info/LICENSE` & `franky_panda-0.3.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `franky_panda-0.3.0.dist-info/RECORD` & `franky_panda-0.3.1.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 franky_panda.libs/libPocoNet-ac8eb170.so.31,sha256=19JOTANuZKAUPi2e9OJq1bF2qgrTOWPCrRcD5qGwb3U,1615409
 franky_panda.libs/libpcre-9513aab5.so.1.2.0,sha256=Au2oUOBJMWVtivgfUXG_902L7BVT09hcPTLX_F7-iGQ,406817
 franky_panda.libs/libPocoFoundation-c26869a6.so.31,sha256=-KR9BM4Jp7wQoZxoW-dXqBFYUpD_9i4iJXZ4b_pLi_k,2252345
 franky/gripper.py,sha256=QHJ2sChhgCMGCyp_ycJtE_0CMKLFERJTArYX2el0LP8,404
 franky/__init__.py,sha256=crdeeZdUur-J5DHa22eoHyyVk3ceoBTcJXhPfx_FP_4,1329
 franky/motion.py,sha256=XhAiockbOzI3XckLjHksGJxlB5edlZVqjFjbnAt7Kvg,272
 franky/robot.py,sha256=GCWQOnhQIv3DhOo5FsHHgsFeNIZX8IQgeJ09VV84DLE,234
-franky/_franky.pyi,sha256=RWVJTMW0sN8TqneABLL6QC3uL77odEOn4ZaCDZhMbmo,40169
+franky/_franky.pyi,sha256=siaDUufc1bnIJEU_iUhgcSLZ13oVrKr0SdVdAhuxrow,41384
 franky/_franky.cpython-39-x86_64-linux-gnu.so,sha256=J_gU3eUWT6YyTXd-w0FtmxSwA_0gayjv00k74waricg,1567009
 franky/reaction.py,sha256=aVI_B2lO4lH2MADEP0SBtVjCjdj2Vn-2UJpco5BS404,1448
 franky/robot_web_session.py,sha256=hUHGnd5nOaT7UnX8SQOlJX9y4dNSgyKjTegW6o_AlmA,2198
-franky_panda-0.3.0.dist-info/METADATA,sha256=uRPLKPcxC5v3-A2abvQSRU2Ou_IbAW_G7kyFJMyeiDM,18732
-franky_panda-0.3.0.dist-info/LICENSE,sha256=6or154nLLU6bELzjh0mCreFjt0m2v72zLi3yHE0QbeE,7650
-franky_panda-0.3.0.dist-info/top_level.txt,sha256=LdDKRvHTODs6ll6Ow5b-gmWqt4NJffHxL83MRTCv_Ag,22
-franky_panda-0.3.0.dist-info/WHEEL,sha256=gREe7-l-MJWbGZG46A7WHnwwUSxA3XJYHQvGGLzmBNU,148
-franky_panda-0.3.0.dist-info/RECORD,,
+franky_panda-0.3.1.dist-info/METADATA,sha256=Da9waiurl9Rs9NCB1irg7TCuHw6GQZscG_zIUjxKLyw,18762
+franky_panda-0.3.1.dist-info/LICENSE,sha256=6or154nLLU6bELzjh0mCreFjt0m2v72zLi3yHE0QbeE,7650
+franky_panda-0.3.1.dist-info/top_level.txt,sha256=LdDKRvHTODs6ll6Ow5b-gmWqt4NJffHxL83MRTCv_Ag,22
+franky_panda-0.3.1.dist-info/WHEEL,sha256=gREe7-l-MJWbGZG46A7WHnwwUSxA3XJYHQvGGLzmBNU,148
+franky_panda-0.3.1.dist-info/RECORD,,
```

