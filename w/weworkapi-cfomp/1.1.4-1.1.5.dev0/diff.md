# Comparing `tmp/weworkapi_cfomp-1.1.4-py3-none-any.whl.zip` & `tmp/weworkapi_cfomp-1.1.5.dev0-py3.6.egg`

## zipinfo {}

```diff
@@ -1,21 +1,37 @@
-Zip file size: 19049 bytes, number of entries: 19
--rw-r--r--  2.0 unx    10387 b- defN 21-May-20 08:38 wework_callback/WXBizMsgCrypt3.py
--rw-r--r--  2.0 unx        0 b- defN 21-May-20 08:38 wework_callback/__init__.py
--rw-r--r--  2.0 unx      796 b- defN 21-May-20 08:38 wework_callback/ierror.py
--rw-r--r--  2.0 unx     6320 b- defN 21-May-20 08:38 wework_callback_json/Sample.py
--rw-r--r--  2.0 unx    10429 b- defN 21-May-20 08:38 wework_callback_json/WXBizJsonMsgCrypt.py
--rw-r--r--  2.0 unx        0 b- defN 21-May-20 08:38 wework_callback_json/__init__.py
--rw-r--r--  2.0 unx      798 b- defN 21-May-20 08:38 wework_callback_json/ierror.py
--rw-r--r--  2.0 unx        0 b- defN 21-Jun-09 05:15 wework_sendmsg/__init__.py
--rw-r--r--  2.0 unx     3171 b- defN 21-Jun-25 07:59 wework_sendmsg/sendmsg.py
--rw-r--r--  2.0 unx     3950 b- defN 21-May-20 08:38 weworkapi/AbstractApi.py
--rw-r--r--  2.0 unx     5498 b- defN 21-May-20 08:38 weworkapi/CorpApi.py
--rw-r--r--  2.0 unx     2895 b- defN 21-May-20 08:38 weworkapi/ServiceCorpApi.py
--rw-r--r--  2.0 unx     1652 b- defN 21-May-20 08:38 weworkapi/ServiceProviderApi.py
--rw-r--r--  2.0 unx        0 b- defN 21-May-20 08:38 weworkapi/__init__.py
--rw-r--r--  2.0 unx      805 b- defN 21-Jul-01 09:23 weworkapi_cfomp-1.1.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 21-Jul-01 09:23 weworkapi_cfomp-1.1.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       64 b- defN 21-Jul-01 09:23 weworkapi_cfomp-1.1.4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       62 b- defN 21-Jul-01 09:23 weworkapi_cfomp-1.1.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1610 b- defN 21-Jul-01 09:23 weworkapi_cfomp-1.1.4.dist-info/RECORD
-19 files, 48529 bytes uncompressed, 16383 bytes compressed:  66.2%
+Zip file size: 36984 bytes, number of entries: 35
+-rw-rw-rw-  2.0 fat      690 b- defN 23-Jun-30 16:57 EGG-INFO/PKG-INFO
+-rw-rw-rw-  2.0 fat      905 b- defN 23-Jun-30 16:57 EGG-INFO/SOURCES.txt
+-rw-rw-rw-  2.0 fat        1 b- defN 23-Jun-30 16:57 EGG-INFO/dependency_links.txt
+-rw-rw-rw-  2.0 fat       64 b- defN 23-Jun-30 16:57 EGG-INFO/entry_points.txt
+-rw-rw-rw-  2.0 fat       64 b- defN 23-Jun-30 16:57 EGG-INFO/requires.txt
+-rw-rw-rw-  2.0 fat       62 b- defN 23-Jun-30 16:57 EGG-INFO/top_level.txt
+-rw-rw-rw-  2.0 fat        2 b- defN 23-Jun-30 16:57 EGG-INFO/zip-safe
+-rw-rw-rw-  2.0 fat    10668 b- defN 23-Jun-19 10:49 wework_callback/WXBizMsgCrypt3.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-19 10:49 wework_callback/__init__.py
+-rw-rw-rw-  2.0 fat      816 b- defN 23-Jun-19 10:49 wework_callback/ierror.py
+-rw-rw-rw-  2.0 fat     7941 b- defN 23-Jun-30 16:57 wework_callback/__pycache__/WXBizMsgCrypt3.cpython-36.pyc
+-rw-rw-rw-  2.0 fat      136 b- defN 23-Jun-30 16:57 wework_callback/__pycache__/__init__.cpython-36.pyc
+-rw-rw-rw-  2.0 fat      701 b- defN 23-Jun-30 16:57 wework_callback/__pycache__/ierror.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     6428 b- defN 23-Jun-19 10:49 wework_callback_json/Sample.py
+-rw-rw-rw-  2.0 fat    10708 b- defN 23-Jun-19 10:49 wework_callback_json/WXBizJsonMsgCrypt.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-19 10:49 wework_callback_json/__init__.py
+-rw-rw-rw-  2.0 fat      818 b- defN 23-Jun-19 10:49 wework_callback_json/ierror.py
+-rw-rw-rw-  2.0 fat      139 b- defN 23-Jun-30 16:57 wework_callback_json/__pycache__/Sample.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     7651 b- defN 23-Jun-30 16:57 wework_callback_json/__pycache__/WXBizJsonMsgCrypt.cpython-36.pyc
+-rw-rw-rw-  2.0 fat      141 b- defN 23-Jun-30 16:57 wework_callback_json/__pycache__/__init__.cpython-36.pyc
+-rw-rw-rw-  2.0 fat      708 b- defN 23-Jun-30 16:57 wework_callback_json/__pycache__/ierror.cpython-36.pyc
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-19 10:49 wework_sendmsg/__init__.py
+-rw-rw-rw-  2.0 fat     3380 b- defN 23-Jun-30 16:57 wework_sendmsg/sendmsg.py
+-rw-rw-rw-  2.0 fat      135 b- defN 23-Jun-30 16:57 wework_sendmsg/__pycache__/__init__.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     2832 b- defN 23-Jun-30 16:57 wework_sendmsg/__pycache__/sendmsg.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     4088 b- defN 23-Jun-19 10:49 weworkapi/AbstractApi.py
+-rw-rw-rw-  2.0 fat     5602 b- defN 23-Jun-19 10:49 weworkapi/CorpApi.py
+-rw-rw-rw-  2.0 fat     2965 b- defN 23-Jun-19 10:49 weworkapi/ServiceCorpApi.py
+-rw-rw-rw-  2.0 fat     1697 b- defN 23-Jun-19 10:49 weworkapi/ServiceProviderApi.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-19 10:49 weworkapi/__init__.py
+-rw-rw-rw-  2.0 fat     4353 b- defN 23-Jun-30 16:57 weworkapi/__pycache__/AbstractApi.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     4686 b- defN 23-Jun-30 16:57 weworkapi/__pycache__/CorpApi.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     2377 b- defN 23-Jun-30 16:57 weworkapi/__pycache__/ServiceCorpApi.cpython-36.pyc
+-rw-rw-rw-  2.0 fat     1531 b- defN 23-Jun-30 16:57 weworkapi/__pycache__/ServiceProviderApi.cpython-36.pyc
+-rw-rw-rw-  2.0 fat      130 b- defN 23-Jun-30 16:57 weworkapi/__pycache__/__init__.cpython-36.pyc
+35 files, 82419 bytes uncompressed, 31760 bytes compressed:  61.5%
```

## zipnote {}

```diff
@@ -1,34 +1,82 @@
+Filename: EGG-INFO/PKG-INFO
+Comment: 
+
+Filename: EGG-INFO/SOURCES.txt
+Comment: 
+
+Filename: EGG-INFO/dependency_links.txt
+Comment: 
+
+Filename: EGG-INFO/entry_points.txt
+Comment: 
+
+Filename: EGG-INFO/requires.txt
+Comment: 
+
+Filename: EGG-INFO/top_level.txt
+Comment: 
+
+Filename: EGG-INFO/zip-safe
+Comment: 
+
 Filename: wework_callback/WXBizMsgCrypt3.py
 Comment: 
 
 Filename: wework_callback/__init__.py
 Comment: 
 
 Filename: wework_callback/ierror.py
 Comment: 
 
+Filename: wework_callback/__pycache__/WXBizMsgCrypt3.cpython-36.pyc
+Comment: 
+
+Filename: wework_callback/__pycache__/__init__.cpython-36.pyc
+Comment: 
+
+Filename: wework_callback/__pycache__/ierror.cpython-36.pyc
+Comment: 
+
 Filename: wework_callback_json/Sample.py
 Comment: 
 
 Filename: wework_callback_json/WXBizJsonMsgCrypt.py
 Comment: 
 
 Filename: wework_callback_json/__init__.py
 Comment: 
 
 Filename: wework_callback_json/ierror.py
 Comment: 
 
+Filename: wework_callback_json/__pycache__/Sample.cpython-36.pyc
+Comment: 
+
+Filename: wework_callback_json/__pycache__/WXBizJsonMsgCrypt.cpython-36.pyc
+Comment: 
+
+Filename: wework_callback_json/__pycache__/__init__.cpython-36.pyc
+Comment: 
+
+Filename: wework_callback_json/__pycache__/ierror.cpython-36.pyc
+Comment: 
+
 Filename: wework_sendmsg/__init__.py
 Comment: 
 
 Filename: wework_sendmsg/sendmsg.py
 Comment: 
 
+Filename: wework_sendmsg/__pycache__/__init__.cpython-36.pyc
+Comment: 
+
+Filename: wework_sendmsg/__pycache__/sendmsg.cpython-36.pyc
+Comment: 
+
 Filename: weworkapi/AbstractApi.py
 Comment: 
 
 Filename: weworkapi/CorpApi.py
 Comment: 
 
 Filename: weworkapi/ServiceCorpApi.py
@@ -36,23 +84,23 @@
 
 Filename: weworkapi/ServiceProviderApi.py
 Comment: 
 
 Filename: weworkapi/__init__.py
 Comment: 
 
-Filename: weworkapi_cfomp-1.1.4.dist-info/METADATA
+Filename: weworkapi/__pycache__/AbstractApi.cpython-36.pyc
 Comment: 
 
-Filename: weworkapi_cfomp-1.1.4.dist-info/WHEEL
+Filename: weworkapi/__pycache__/CorpApi.cpython-36.pyc
 Comment: 
 
-Filename: weworkapi_cfomp-1.1.4.dist-info/entry_points.txt
+Filename: weworkapi/__pycache__/ServiceCorpApi.cpython-36.pyc
 Comment: 
 
-Filename: weworkapi_cfomp-1.1.4.dist-info/top_level.txt
+Filename: weworkapi/__pycache__/ServiceProviderApi.cpython-36.pyc
 Comment: 
 
-Filename: weworkapi_cfomp-1.1.4.dist-info/RECORD
+Filename: weworkapi/__pycache__/__init__.cpython-36.pyc
 Comment: 
 
 Zip file comment:
```

## wework_callback/WXBizMsgCrypt3.py

 * *Ordering differences only*

```diff
@@ -1,281 +1,281 @@
-#!/usr/bin/env python
-# -*- encoding:utf-8 -*-
-
-""" 对企业微信发送给企业后台的消息加解密示例代码.
-@copyright: Copyright (c) 1998-2014 Tencent Inc.
-
-"""
-# ------------------------------------------------------------------------
-import logging
-import base64
-import random
-import hashlib
-import time
-import struct
-from Crypto.Cipher import AES
-import xml.etree.cElementTree as ET
-import socket
-
-from . import ierror
-# import ierror
-
-
-"""
-关于Crypto.Cipher模块，ImportError: No module named 'Crypto'解决方案
-请到官方网站 https://www.dlitz.net/software/pycrypto/ 下载pycrypto。
-下载后，按照README中的“Installation”小节的提示进行pycrypto安装。
-"""
-
-
-class FormatException(Exception):
-    pass
-
-
-def throw_exception(message, exception_class=FormatException):
-    """my define raise exception function"""
-    raise exception_class(message)
-
-
-class SHA1:
-    """计算企业微信的消息签名接口"""
-
-    def getSHA1(self, token, timestamp, nonce, encrypt):
-        """用SHA1算法生成安全签名
-        @param token:  票据
-        @param timestamp: 时间戳
-        @param encrypt: 密文
-        @param nonce: 随机字符串
-        @return: 安全签名
-        """
-        try:
-            sortlist = [token, timestamp, nonce, encrypt]
-            sortlist.sort()
-            sha = hashlib.sha1()
-            sha.update("".join(sortlist).encode())
-            return ierror.WXBizMsgCrypt_OK, sha.hexdigest()
-        except Exception as e:
-            logger = logging.getLogger()
-            logger.error(e)
-            return ierror.WXBizMsgCrypt_ComputeSignature_Error, None
-
-
-class XMLParse:
-    """提供提取消息格式中的密文及生成回复消息格式的接口"""
-
-    # xml消息模板
-    AES_TEXT_RESPONSE_TEMPLATE = """<xml>
-<Encrypt><![CDATA[%(msg_encrypt)s]]></Encrypt>
-<MsgSignature><![CDATA[%(msg_signaturet)s]]></MsgSignature>
-<TimeStamp>%(timestamp)s</TimeStamp>
-<Nonce><![CDATA[%(nonce)s]]></Nonce>
-</xml>"""
-
-    def extract(self, xmltext):
-        """提取出xml数据包中的加密消息
-        @param xmltext: 待提取的xml字符串
-        @return: 提取出的加密消息字符串
-        """
-        try:
-            xml_tree = ET.fromstring(xmltext)
-            encrypt = xml_tree.find("Encrypt")
-            return ierror.WXBizMsgCrypt_OK, encrypt.text
-        except Exception as e:
-            logger = logging.getLogger()
-            logger.error(e)
-            return ierror.WXBizMsgCrypt_ParseXml_Error, None
-
-    def generate(self, encrypt, signature, timestamp, nonce):
-        """生成xml消息
-        @param encrypt: 加密后的消息密文
-        @param signature: 安全签名
-        @param timestamp: 时间戳
-        @param nonce: 随机字符串
-        @return: 生成的xml字符串
-        """
-        resp_dict = {
-            'msg_encrypt': encrypt,
-            'msg_signaturet': signature,
-            'timestamp': timestamp,
-            'nonce': nonce,
-        }
-        resp_xml = self.AES_TEXT_RESPONSE_TEMPLATE % resp_dict
-        return resp_xml
-
-
-class PKCS7Encoder():
-    """提供基于PKCS7算法的加解密接口"""
-
-    block_size = 32
-
-    def encode(self, text):
-        """ 对需要加密的明文进行填充补位
-        @param text: 需要进行填充补位操作的明文
-        @return: 补齐明文字符串
-        """
-        text_length = len(text)
-        # 计算需要填充的位数
-        amount_to_pad = self.block_size - (text_length % self.block_size)
-        if amount_to_pad == 0:
-            amount_to_pad = self.block_size
-        # 获得补位所用的字符
-        pad = chr(amount_to_pad)
-        return text + (pad * amount_to_pad).encode()
-
-    def decode(self, decrypted):
-        """删除解密后明文的补位字符
-        @param decrypted: 解密后的明文
-        @return: 删除补位字符后的明文
-        """
-        pad = ord(decrypted[-1])
-        if pad < 1 or pad > 32:
-            pad = 0
-        return decrypted[:-pad]
-
-
-class Prpcrypt(object):
-    """提供接收和推送给企业微信消息的加解密接口"""
-
-    def __init__(self, key):
-
-        # self.key = base64.b64decode(key+"=")
-        self.key = key
-        # 设置加解密模式为AES的CBC模式
-        self.mode = AES.MODE_CBC
-
-    def encrypt(self, text, receiveid):
-        """对明文进行加密
-        @param text: 需要加密的明文
-        @return: 加密得到的字符串
-        """
-        # 16位随机字符串添加到明文开头
-        text = text.encode()
-        text = self.get_random_str() + struct.pack("I", socket.htonl(len(text))) + text + receiveid.encode()
-
-        # 使用自定义的填充方式对明文进行补位填充
-        pkcs7 = PKCS7Encoder()
-        text = pkcs7.encode(text)
-        # 加密
-        cryptor = AES.new(self.key, self.mode, self.key[:16])
-        try:
-            ciphertext = cryptor.encrypt(text)
-            # 使用BASE64对加密后的字符串进行编码
-            return ierror.WXBizMsgCrypt_OK, base64.b64encode(ciphertext)
-        except Exception as e:
-            logger = logging.getLogger()
-            logger.error(e)
-            return ierror.WXBizMsgCrypt_EncryptAES_Error, None
-
-    def decrypt(self, text, receiveid):
-        """对解密后的明文进行补位删除
-        @param text: 密文
-        @return: 删除填充补位后的明文
-        """
-        try:
-            cryptor = AES.new(self.key, self.mode, self.key[:16])
-            # 使用BASE64对密文进行解码，然后AES-CBC解密
-            plain_text = cryptor.decrypt(base64.b64decode(text))
-        except Exception as e:
-            logger = logging.getLogger()
-            logger.error(e)
-            return ierror.WXBizMsgCrypt_DecryptAES_Error, None
-        try:
-            pad = plain_text[-1]
-            # 去掉补位字符串
-            # pkcs7 = PKCS7Encoder()
-            # plain_text = pkcs7.encode(plain_text)
-            # 去除16位随机字符串
-            content = plain_text[16:-pad]
-            xml_len = socket.ntohl(struct.unpack("I", content[: 4])[0])
-            xml_content = content[4: xml_len + 4]
-            from_receiveid = content[xml_len + 4:]
-        except Exception as e:
-            logger = logging.getLogger()
-            logger.error(e)
-            return ierror.WXBizMsgCrypt_IllegalBuffer, None
-
-        if from_receiveid.decode('utf8') != receiveid:
-            return ierror.WXBizMsgCrypt_ValidateCorpid_Error, None
-        return 0, xml_content
-
-    def get_random_str(self):
-        """ 随机生成16位字符串
-        @return: 16位字符串
-        """
-        return str(random.randint(1000000000000000, 9999999999999999)).encode()
-
-
-class WXBizMsgCrypt(object):
-    # 构造函数
-    def __init__(self, sToken, sEncodingAESKey, sReceiveId):
-        try:
-            self.key = base64.b64decode(sEncodingAESKey + "=")
-            assert len(self.key) == 32
-        except:
-            throw_exception("[error]: EncodingAESKey unvalid !", FormatException)
-            # return ierror.WXBizMsgCrypt_IllegalAesKey,None
-        self.m_sToken = sToken
-        self.m_sReceiveId = sReceiveId
-
-        # 验证URL
-        # @param sMsgSignature: 签名串，对应URL参数的msg_signature
-        # @param sTimeStamp: 时间戳，对应URL参数的timestamp
-        # @param sNonce: 随机串，对应URL参数的nonce
-        # @param sEchoStr: 随机串，对应URL参数的echostr
-        # @param sReplyEchoStr: 解密之后的echostr，当return返回0时有效
-        # @return：成功0，失败返回对应的错误码
-
-    def VerifyURL(self, sMsgSignature, sTimeStamp, sNonce, sEchoStr):
-        sha1 = SHA1()
-        ret, signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, sEchoStr)
-        if ret != 0:
-            return ret, None
-        if not signature == sMsgSignature:
-            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
-        pc = Prpcrypt(self.key)
-        ret, sReplyEchoStr = pc.decrypt(sEchoStr, self.m_sReceiveId)
-        return ret, sReplyEchoStr
-
-    def EncryptMsg(self, sReplyMsg, sNonce, timestamp=None):
-        # 将企业回复用户的消息加密打包
-        # @param sReplyMsg: 企业号待回复用户的消息，xml格式的字符串
-        # @param sTimeStamp: 时间戳，可以自己生成，也可以用URL参数的timestamp,如为None则自动用当前时间
-        # @param sNonce: 随机串，可以自己生成，也可以用URL参数的nonce
-        # sEncryptMsg: 加密后的可以直接回复用户的密文，包括msg_signature, timestamp, nonce, encrypt的xml格式的字符串,
-        # return：成功0，sEncryptMsg,失败返回对应的错误码None
-        pc = Prpcrypt(self.key)
-        ret, encrypt = pc.encrypt(sReplyMsg, self.m_sReceiveId)
-        encrypt = encrypt.decode('utf8')
-        if ret != 0:
-            return ret, None
-        if timestamp is None:
-            timestamp = str(int(time.time()))
-        # 生成安全签名
-        sha1 = SHA1()
-        ret, signature = sha1.getSHA1(self.m_sToken, timestamp, sNonce, encrypt)
-        if ret != 0:
-            return ret, None
-        xmlParse = XMLParse()
-        return ret, xmlParse.generate(encrypt, signature, timestamp, sNonce)
-
-    def DecryptMsg(self, sPostData, sMsgSignature, sTimeStamp, sNonce):
-        # 检验消息的真实性，并且获取解密后的明文
-        # @param sMsgSignature: 签名串，对应URL参数的msg_signature
-        # @param sTimeStamp: 时间戳，对应URL参数的timestamp
-        # @param sNonce: 随机串，对应URL参数的nonce
-        # @param sPostData: 密文，对应POST请求的数据
-        #  xml_content: 解密后的原文，当return返回0时有效
-        # @return: 成功0，失败返回对应的错误码
-        # 验证安全签名
-        xmlParse = XMLParse()
-        ret, encrypt = xmlParse.extract(sPostData)
-        if ret != 0:
-            return ret, None
-        sha1 = SHA1()
-        ret, signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, encrypt)
-        if ret != 0:
-            return ret, None
-        if not signature == sMsgSignature:
-            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
-        pc = Prpcrypt(self.key)
-        ret, xml_content = pc.decrypt(encrypt, self.m_sReceiveId)
-        return ret, xml_content
+#!/usr/bin/env python
+# -*- encoding:utf-8 -*-
+
+""" 对企业微信发送给企业后台的消息加解密示例代码.
+@copyright: Copyright (c) 1998-2014 Tencent Inc.
+
+"""
+# ------------------------------------------------------------------------
+import logging
+import base64
+import random
+import hashlib
+import time
+import struct
+from Crypto.Cipher import AES
+import xml.etree.cElementTree as ET
+import socket
+
+from . import ierror
+# import ierror
+
+
+"""
+关于Crypto.Cipher模块，ImportError: No module named 'Crypto'解决方案
+请到官方网站 https://www.dlitz.net/software/pycrypto/ 下载pycrypto。
+下载后，按照README中的“Installation”小节的提示进行pycrypto安装。
+"""
+
+
+class FormatException(Exception):
+    pass
+
+
+def throw_exception(message, exception_class=FormatException):
+    """my define raise exception function"""
+    raise exception_class(message)
+
+
+class SHA1:
+    """计算企业微信的消息签名接口"""
+
+    def getSHA1(self, token, timestamp, nonce, encrypt):
+        """用SHA1算法生成安全签名
+        @param token:  票据
+        @param timestamp: 时间戳
+        @param encrypt: 密文
+        @param nonce: 随机字符串
+        @return: 安全签名
+        """
+        try:
+            sortlist = [token, timestamp, nonce, encrypt]
+            sortlist.sort()
+            sha = hashlib.sha1()
+            sha.update("".join(sortlist).encode())
+            return ierror.WXBizMsgCrypt_OK, sha.hexdigest()
+        except Exception as e:
+            logger = logging.getLogger()
+            logger.error(e)
+            return ierror.WXBizMsgCrypt_ComputeSignature_Error, None
+
+
+class XMLParse:
+    """提供提取消息格式中的密文及生成回复消息格式的接口"""
+
+    # xml消息模板
+    AES_TEXT_RESPONSE_TEMPLATE = """<xml>
+<Encrypt><![CDATA[%(msg_encrypt)s]]></Encrypt>
+<MsgSignature><![CDATA[%(msg_signaturet)s]]></MsgSignature>
+<TimeStamp>%(timestamp)s</TimeStamp>
+<Nonce><![CDATA[%(nonce)s]]></Nonce>
+</xml>"""
+
+    def extract(self, xmltext):
+        """提取出xml数据包中的加密消息
+        @param xmltext: 待提取的xml字符串
+        @return: 提取出的加密消息字符串
+        """
+        try:
+            xml_tree = ET.fromstring(xmltext)
+            encrypt = xml_tree.find("Encrypt")
+            return ierror.WXBizMsgCrypt_OK, encrypt.text
+        except Exception as e:
+            logger = logging.getLogger()
+            logger.error(e)
+            return ierror.WXBizMsgCrypt_ParseXml_Error, None
+
+    def generate(self, encrypt, signature, timestamp, nonce):
+        """生成xml消息
+        @param encrypt: 加密后的消息密文
+        @param signature: 安全签名
+        @param timestamp: 时间戳
+        @param nonce: 随机字符串
+        @return: 生成的xml字符串
+        """
+        resp_dict = {
+            'msg_encrypt': encrypt,
+            'msg_signaturet': signature,
+            'timestamp': timestamp,
+            'nonce': nonce,
+        }
+        resp_xml = self.AES_TEXT_RESPONSE_TEMPLATE % resp_dict
+        return resp_xml
+
+
+class PKCS7Encoder():
+    """提供基于PKCS7算法的加解密接口"""
+
+    block_size = 32
+
+    def encode(self, text):
+        """ 对需要加密的明文进行填充补位
+        @param text: 需要进行填充补位操作的明文
+        @return: 补齐明文字符串
+        """
+        text_length = len(text)
+        # 计算需要填充的位数
+        amount_to_pad = self.block_size - (text_length % self.block_size)
+        if amount_to_pad == 0:
+            amount_to_pad = self.block_size
+        # 获得补位所用的字符
+        pad = chr(amount_to_pad)
+        return text + (pad * amount_to_pad).encode()
+
+    def decode(self, decrypted):
+        """删除解密后明文的补位字符
+        @param decrypted: 解密后的明文
+        @return: 删除补位字符后的明文
+        """
+        pad = ord(decrypted[-1])
+        if pad < 1 or pad > 32:
+            pad = 0
+        return decrypted[:-pad]
+
+
+class Prpcrypt(object):
+    """提供接收和推送给企业微信消息的加解密接口"""
+
+    def __init__(self, key):
+
+        # self.key = base64.b64decode(key+"=")
+        self.key = key
+        # 设置加解密模式为AES的CBC模式
+        self.mode = AES.MODE_CBC
+
+    def encrypt(self, text, receiveid):
+        """对明文进行加密
+        @param text: 需要加密的明文
+        @return: 加密得到的字符串
+        """
+        # 16位随机字符串添加到明文开头
+        text = text.encode()
+        text = self.get_random_str() + struct.pack("I", socket.htonl(len(text))) + text + receiveid.encode()
+
+        # 使用自定义的填充方式对明文进行补位填充
+        pkcs7 = PKCS7Encoder()
+        text = pkcs7.encode(text)
+        # 加密
+        cryptor = AES.new(self.key, self.mode, self.key[:16])
+        try:
+            ciphertext = cryptor.encrypt(text)
+            # 使用BASE64对加密后的字符串进行编码
+            return ierror.WXBizMsgCrypt_OK, base64.b64encode(ciphertext)
+        except Exception as e:
+            logger = logging.getLogger()
+            logger.error(e)
+            return ierror.WXBizMsgCrypt_EncryptAES_Error, None
+
+    def decrypt(self, text, receiveid):
+        """对解密后的明文进行补位删除
+        @param text: 密文
+        @return: 删除填充补位后的明文
+        """
+        try:
+            cryptor = AES.new(self.key, self.mode, self.key[:16])
+            # 使用BASE64对密文进行解码，然后AES-CBC解密
+            plain_text = cryptor.decrypt(base64.b64decode(text))
+        except Exception as e:
+            logger = logging.getLogger()
+            logger.error(e)
+            return ierror.WXBizMsgCrypt_DecryptAES_Error, None
+        try:
+            pad = plain_text[-1]
+            # 去掉补位字符串
+            # pkcs7 = PKCS7Encoder()
+            # plain_text = pkcs7.encode(plain_text)
+            # 去除16位随机字符串
+            content = plain_text[16:-pad]
+            xml_len = socket.ntohl(struct.unpack("I", content[: 4])[0])
+            xml_content = content[4: xml_len + 4]
+            from_receiveid = content[xml_len + 4:]
+        except Exception as e:
+            logger = logging.getLogger()
+            logger.error(e)
+            return ierror.WXBizMsgCrypt_IllegalBuffer, None
+
+        if from_receiveid.decode('utf8') != receiveid:
+            return ierror.WXBizMsgCrypt_ValidateCorpid_Error, None
+        return 0, xml_content
+
+    def get_random_str(self):
+        """ 随机生成16位字符串
+        @return: 16位字符串
+        """
+        return str(random.randint(1000000000000000, 9999999999999999)).encode()
+
+
+class WXBizMsgCrypt(object):
+    # 构造函数
+    def __init__(self, sToken, sEncodingAESKey, sReceiveId):
+        try:
+            self.key = base64.b64decode(sEncodingAESKey + "=")
+            assert len(self.key) == 32
+        except:
+            throw_exception("[error]: EncodingAESKey unvalid !", FormatException)
+            # return ierror.WXBizMsgCrypt_IllegalAesKey,None
+        self.m_sToken = sToken
+        self.m_sReceiveId = sReceiveId
+
+        # 验证URL
+        # @param sMsgSignature: 签名串，对应URL参数的msg_signature
+        # @param sTimeStamp: 时间戳，对应URL参数的timestamp
+        # @param sNonce: 随机串，对应URL参数的nonce
+        # @param sEchoStr: 随机串，对应URL参数的echostr
+        # @param sReplyEchoStr: 解密之后的echostr，当return返回0时有效
+        # @return：成功0，失败返回对应的错误码
+
+    def VerifyURL(self, sMsgSignature, sTimeStamp, sNonce, sEchoStr):
+        sha1 = SHA1()
+        ret, signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, sEchoStr)
+        if ret != 0:
+            return ret, None
+        if not signature == sMsgSignature:
+            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
+        pc = Prpcrypt(self.key)
+        ret, sReplyEchoStr = pc.decrypt(sEchoStr, self.m_sReceiveId)
+        return ret, sReplyEchoStr
+
+    def EncryptMsg(self, sReplyMsg, sNonce, timestamp=None):
+        # 将企业回复用户的消息加密打包
+        # @param sReplyMsg: 企业号待回复用户的消息，xml格式的字符串
+        # @param sTimeStamp: 时间戳，可以自己生成，也可以用URL参数的timestamp,如为None则自动用当前时间
+        # @param sNonce: 随机串，可以自己生成，也可以用URL参数的nonce
+        # sEncryptMsg: 加密后的可以直接回复用户的密文，包括msg_signature, timestamp, nonce, encrypt的xml格式的字符串,
+        # return：成功0，sEncryptMsg,失败返回对应的错误码None
+        pc = Prpcrypt(self.key)
+        ret, encrypt = pc.encrypt(sReplyMsg, self.m_sReceiveId)
+        encrypt = encrypt.decode('utf8')
+        if ret != 0:
+            return ret, None
+        if timestamp is None:
+            timestamp = str(int(time.time()))
+        # 生成安全签名
+        sha1 = SHA1()
+        ret, signature = sha1.getSHA1(self.m_sToken, timestamp, sNonce, encrypt)
+        if ret != 0:
+            return ret, None
+        xmlParse = XMLParse()
+        return ret, xmlParse.generate(encrypt, signature, timestamp, sNonce)
+
+    def DecryptMsg(self, sPostData, sMsgSignature, sTimeStamp, sNonce):
+        # 检验消息的真实性，并且获取解密后的明文
+        # @param sMsgSignature: 签名串，对应URL参数的msg_signature
+        # @param sTimeStamp: 时间戳，对应URL参数的timestamp
+        # @param sNonce: 随机串，对应URL参数的nonce
+        # @param sPostData: 密文，对应POST请求的数据
+        #  xml_content: 解密后的原文，当return返回0时有效
+        # @return: 成功0，失败返回对应的错误码
+        # 验证安全签名
+        xmlParse = XMLParse()
+        ret, encrypt = xmlParse.extract(sPostData)
+        if ret != 0:
+            return ret, None
+        sha1 = SHA1()
+        ret, signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, encrypt)
+        if ret != 0:
+            return ret, None
+        if not signature == sMsgSignature:
+            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
+        pc = Prpcrypt(self.key)
+        ret, xml_content = pc.decrypt(encrypt, self.m_sReceiveId)
+        return ret, xml_content
```

## wework_callback/ierror.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#########################################################################
-# Author: jonyqin
-# Created Time: Thu 11 Sep 2014 01:53:58 PM CST
-# File Name: ierror.py
-# Description:定义错误码含义 
-#########################################################################
-WXBizMsgCrypt_OK = 0
-WXBizMsgCrypt_ValidateSignature_Error = -40001
-WXBizMsgCrypt_ParseXml_Error = -40002
-WXBizMsgCrypt_ComputeSignature_Error = -40003
-WXBizMsgCrypt_IllegalAesKey = -40004
-WXBizMsgCrypt_ValidateCorpid_Error = -40005
-WXBizMsgCrypt_EncryptAES_Error = -40006
-WXBizMsgCrypt_DecryptAES_Error = -40007
-WXBizMsgCrypt_IllegalBuffer = -40008
-WXBizMsgCrypt_EncodeBase64_Error = -40009
-WXBizMsgCrypt_DecodeBase64_Error = -40010
-WXBizMsgCrypt_GenReturnXml_Error = -40011
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#########################################################################
+# Author: jonyqin
+# Created Time: Thu 11 Sep 2014 01:53:58 PM CST
+# File Name: ierror.py
+# Description:定义错误码含义 
+#########################################################################
+WXBizMsgCrypt_OK = 0
+WXBizMsgCrypt_ValidateSignature_Error = -40001
+WXBizMsgCrypt_ParseXml_Error = -40002
+WXBizMsgCrypt_ComputeSignature_Error = -40003
+WXBizMsgCrypt_IllegalAesKey = -40004
+WXBizMsgCrypt_ValidateCorpid_Error = -40005
+WXBizMsgCrypt_EncryptAES_Error = -40006
+WXBizMsgCrypt_DecryptAES_Error = -40007
+WXBizMsgCrypt_IllegalBuffer = -40008
+WXBizMsgCrypt_EncodeBase64_Error = -40009
+WXBizMsgCrypt_DecodeBase64_Error = -40010
+WXBizMsgCrypt_GenReturnXml_Error = -40011
```

## wework_callback_json/Sample.py

 * *Ordering differences only*

```diff
@@ -1,108 +1,108 @@
-# #!/usr/bin/env python
-# # -*- coding: utf-8 -*-
-# #########################################################################
-# # Author: jonyqin
-# # Created Time: Thu 11 Sep 2014 03:55:41 PM CST
-# # File Name: Sample.py
-# # Description: WXBizJsonMsgCrypt 使用demo文件
-# #########################################################################
-# from WXBizJsonMsgCrypt import WXBizJsonMsgCrypt
-# import sys
-
-# if __name__ == "__main__":   
-#    #假设企业在企业微信后台上设置的参数如下
-#    sToken = "hJqcu3uJ9Tn2gXPmxx2w9kkCkCE2EPYo"
-#    sEncodingAESKey = "6qkdMrq68nTKduznJYO1A37W2oEgpkMUvkttRToqhUt"
-#    sCorpID = "ww1436e0e65a779aee"
-#    '''
-# 	------------使用示例一：验证回调URL---------------
-# 	*企业开启回调模式时，企业号会向验证url发送一个get请求 
-# 	假设点击验证时，企业收到类似请求：
-# 	* GET /cgi-bin/wxpush?msg_signature=5c45ff5e21c57e6ad56bac8758b79b1d9ac89fd3&timestamp=1409659589&nonce=263014780&echostr=P9nAzCzyDtyTWESHep1vC5X9xho%2FqYX3Zpb4yKa9SKld1DsH3Iyt3tP3zNdtp%2B4RPcs8TgAE7OaBO%2BFZXvnaqQ%3D%3D 
-# 	* HTTP/1.1 Host: qy.weixin.qq.com
-
-# 	接收到该请求时，企业应	1.解析出Get请求的参数，包括消息体签名(msg_signature)，时间戳(timestamp)，随机数字串(nonce)以及企业微信推送过来的随机加密字符串(echostr),
-# 	这一步注意作URL解码。
-# 	2.验证消息体签名的正确性 
-# 	3. 解密出echostr原文，将原文当作Get请求的response，返回给企业微信
-# 	第2，3步可以用企业微信提供的库函数VerifyURL来实现。
-#    '''
-#    wxcpt=WXBizJsonMsgCrypt(sToken,sEncodingAESKey,sCorpID)
-#    sVerifyMsgSig="012bc692d0a58dd4b10f8dfe5c4ac00ae211ebeb"
-#    sVerifyTimeStamp="1476416373"
-#    sVerifyNonce="47744683"
-#    sVerifyEchoStr="fsi1xnbH4yQh0+PJxcOdhhK6TDXkjMyhEPA7xB2TGz6b+g7xyAbEkRxN/3cNXW9qdqjnoVzEtpbhnFyq6SVHyA=="
-#    ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)
-#    if(ret!=0):
-#       print "ERR: VerifyURL ret: " + str(ret)
-#       sys.exit(1)
-#    else:
-#       print "done VerifyURL"
-#       #验证URL成功，将sEchoStr返回给企业号
-
-#    print "=============================="
-#    '''
-#    ------------使用示例二：对用户回复的消息解密---------------
-#    用户回复消息或者点击事件响应时，企业会收到回调消息，此消息是经过企业微信加密之后的密文以post形式发送给企业，密文格式请参考官方文档
-#    假设企业收到企业微信的回调消息如下：
-#    POST /cgi-bin/wxpush? msg_signature=e3647471e395139e2308c1fa963f2d648a00b90e&timestamp=1409659813&nonce=1372623149 HTTP/1.1
-#    Host: qy.weixin.qq.com
-
-#    { 
-#     "tousername": "wx5823bf96d3bd56c7", 
-#     "encrypt": "cjhLUX7UU4yCSelv1vz7T0zT8huF51bAMVWriNvO1FMegHrQZNrtvRxbwf0fUPsFvwqR0U0fgiJNEA5Y30F2MoI2S7vv3EjVQ68C0cjw9frBoUE2Hj0BvFp9h3u6Vbsg4lc1C8AtHdaN8orKuNKkLRLuYEL52R1J3v8olJGZRLnRdVKIivixmX/eQpzgeExtp20jI1HxRP1AAZ6xZoILdqDPO549LO4WeG+685JRUTdiwcY5fjZlqeMxuT4PpMn1X9OWsS7NRj06Wa5E3Tvg4twjWp39KPfOdRte6P1T4JU=", 
-#     "agentid": 218 
-#    }
-
-#    企业收到post请求之后应该 1.解析出url上的参数，包括消息体签名(msg_signature)，时间戳(timestamp)以及随机数字串(nonce)
-#    2.验证消息体签名的正确性。 3.将post请求的数据进行json解析，并将"encrypt"标签的内容进行解密，解密出来的明文即是用户回复消息的明文，明文格式请参考官方文档
-#    第2，3步可以用企业微信提供的库函数DecryptMsg来实现。
-#    '''
-
-#    sReqNonce = "1372623149"
-#    sReqTimeStamp = "1409659813"
-
-#    sReqMsgSig = "e3647471e395139e2308c1fa963f2d648a00b90e"
-#    sReqData = '{ "tousername": "wx5823bf96d3bd56c7", "encrypt": "cjhLUX7UU4yCSelv1vz7T0zT8huF51bAMVWriNvO1FMegHrQZNrtvRxbwf0fUPsFvwqR0U0fgiJNEA5Y30F2MoI2S7vv3EjVQ68C0cjw9frBoUE2Hj0BvFp9h3u6Vbsg4lc1C8AtHdaN8orKuNKkLRLuYEL52R1J3v8olJGZRLnRdVKIivixmX/eQpzgeExtp20jI1HxRP1AAZ6xZoILdqDPO549LO4WeG+685JRUTdiwcY5fjZlqeMxuT4PpMn1X9OWsS7NRj06Wa5E3Tvg4twjWp39KPfOdRte6P1T4JU=", "agentid": 218 }';
-#    ret,sMsg=wxcpt.DecryptMsg( sReqData, sReqMsgSig, sReqTimeStamp, sReqNonce)
-#    if( ret!=0 ):
-#       print "ERR: DecryptMsg ret: " + str(ret)
-#       sys.exit(1)
-#    else:
-#       print sMsg
-#    # 解密成功，sMsg即为json格式的明文
-#    # TODO: 对明文的处理
-#    # ...
-#    # ...
-
-#    print "=============================="
-   
-#    '''
-#    ------------使用示例三：企业回复用户消息的加密---------------
-#    企业被动回复用户的消息也需要进行加密，并且拼接成密文格式的json串。
-#    假设企业需要回复用户的明文如下：
-
-#     { 
-#             "ToUserName": "mycreate",
-#             "FromUserName":"wx5823bf96d3bd56c7",
-#             "CreateTime": 1348831860,
-#             "MsgType": "text",
-#             "Content": "this is a test",
-#             "MsgId": 1234567890123456,
-#             "AgentID": 128
-#     }
-
-#    为了将此段明文回复给用户，企业应： 1.自己生成时间时间戳(timestamp),随机数字串(nonce)以便生成消息体签名，也可以直接用从企业微信的post url上解析出的对应值。
-#    2.将明文加密得到密文。   3.用密文，步骤1生成的timestamp,nonce和企业在企业微信设定的token生成消息体签名。   4.将密文，消息体签名，时间戳，随机数字串拼接成json格式的字符串，发送给企业号。
-#    以上2，3，4步可以用企业微信提供的库函数EncryptMsg来实现。
-#    '''
-#    #sRespData = ' { "ToUserName": "mycreate", "FromUserName":"wx5823bf96d3bd56c7", "CreateTime": 1348831860, "MsgType": "text", "Content": "this is a test", "MsgId": 1234567890123456, "AgentID": 128 }';
-#    sRespData = '{ "ToUserName": "wx5823bf96d3bd56c7", "FromUserName": :mycreate", "CreateTime": 1409659813, "MsgType": "text", "Content": "hello", "MsgId": 4561255354251345929, "AgentID": 218}'
-#    ret,sEncryptMsg=wxcpt.EncryptMsg(sRespData, sReqNonce, sReqTimeStamp)
-#    if( ret!=0 ):
-#       print "ERR: EncryptMsg ret: " + str(ret)
-#       sys.exit(1)
-#    else:
-#       print sEncryptMsg
-#       #ret == 0 加密成功，企业需要将sEncryptMsg返回给企业号
-#    print "=============================="
+# #!/usr/bin/env python
+# # -*- coding: utf-8 -*-
+# #########################################################################
+# # Author: jonyqin
+# # Created Time: Thu 11 Sep 2014 03:55:41 PM CST
+# # File Name: Sample.py
+# # Description: WXBizJsonMsgCrypt 使用demo文件
+# #########################################################################
+# from WXBizJsonMsgCrypt import WXBizJsonMsgCrypt
+# import sys
+
+# if __name__ == "__main__":   
+#    #假设企业在企业微信后台上设置的参数如下
+#    sToken = "hJqcu3uJ9Tn2gXPmxx2w9kkCkCE2EPYo"
+#    sEncodingAESKey = "6qkdMrq68nTKduznJYO1A37W2oEgpkMUvkttRToqhUt"
+#    sCorpID = "ww1436e0e65a779aee"
+#    '''
+# 	------------使用示例一：验证回调URL---------------
+# 	*企业开启回调模式时，企业号会向验证url发送一个get请求 
+# 	假设点击验证时，企业收到类似请求：
+# 	* GET /cgi-bin/wxpush?msg_signature=5c45ff5e21c57e6ad56bac8758b79b1d9ac89fd3&timestamp=1409659589&nonce=263014780&echostr=P9nAzCzyDtyTWESHep1vC5X9xho%2FqYX3Zpb4yKa9SKld1DsH3Iyt3tP3zNdtp%2B4RPcs8TgAE7OaBO%2BFZXvnaqQ%3D%3D 
+# 	* HTTP/1.1 Host: qy.weixin.qq.com
+
+# 	接收到该请求时，企业应	1.解析出Get请求的参数，包括消息体签名(msg_signature)，时间戳(timestamp)，随机数字串(nonce)以及企业微信推送过来的随机加密字符串(echostr),
+# 	这一步注意作URL解码。
+# 	2.验证消息体签名的正确性 
+# 	3. 解密出echostr原文，将原文当作Get请求的response，返回给企业微信
+# 	第2，3步可以用企业微信提供的库函数VerifyURL来实现。
+#    '''
+#    wxcpt=WXBizJsonMsgCrypt(sToken,sEncodingAESKey,sCorpID)
+#    sVerifyMsgSig="012bc692d0a58dd4b10f8dfe5c4ac00ae211ebeb"
+#    sVerifyTimeStamp="1476416373"
+#    sVerifyNonce="47744683"
+#    sVerifyEchoStr="fsi1xnbH4yQh0+PJxcOdhhK6TDXkjMyhEPA7xB2TGz6b+g7xyAbEkRxN/3cNXW9qdqjnoVzEtpbhnFyq6SVHyA=="
+#    ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)
+#    if(ret!=0):
+#       print "ERR: VerifyURL ret: " + str(ret)
+#       sys.exit(1)
+#    else:
+#       print "done VerifyURL"
+#       #验证URL成功，将sEchoStr返回给企业号
+
+#    print "=============================="
+#    '''
+#    ------------使用示例二：对用户回复的消息解密---------------
+#    用户回复消息或者点击事件响应时，企业会收到回调消息，此消息是经过企业微信加密之后的密文以post形式发送给企业，密文格式请参考官方文档
+#    假设企业收到企业微信的回调消息如下：
+#    POST /cgi-bin/wxpush? msg_signature=e3647471e395139e2308c1fa963f2d648a00b90e&timestamp=1409659813&nonce=1372623149 HTTP/1.1
+#    Host: qy.weixin.qq.com
+
+#    { 
+#     "tousername": "wx5823bf96d3bd56c7", 
+#     "encrypt": "cjhLUX7UU4yCSelv1vz7T0zT8huF51bAMVWriNvO1FMegHrQZNrtvRxbwf0fUPsFvwqR0U0fgiJNEA5Y30F2MoI2S7vv3EjVQ68C0cjw9frBoUE2Hj0BvFp9h3u6Vbsg4lc1C8AtHdaN8orKuNKkLRLuYEL52R1J3v8olJGZRLnRdVKIivixmX/eQpzgeExtp20jI1HxRP1AAZ6xZoILdqDPO549LO4WeG+685JRUTdiwcY5fjZlqeMxuT4PpMn1X9OWsS7NRj06Wa5E3Tvg4twjWp39KPfOdRte6P1T4JU=", 
+#     "agentid": 218 
+#    }
+
+#    企业收到post请求之后应该 1.解析出url上的参数，包括消息体签名(msg_signature)，时间戳(timestamp)以及随机数字串(nonce)
+#    2.验证消息体签名的正确性。 3.将post请求的数据进行json解析，并将"encrypt"标签的内容进行解密，解密出来的明文即是用户回复消息的明文，明文格式请参考官方文档
+#    第2，3步可以用企业微信提供的库函数DecryptMsg来实现。
+#    '''
+
+#    sReqNonce = "1372623149"
+#    sReqTimeStamp = "1409659813"
+
+#    sReqMsgSig = "e3647471e395139e2308c1fa963f2d648a00b90e"
+#    sReqData = '{ "tousername": "wx5823bf96d3bd56c7", "encrypt": "cjhLUX7UU4yCSelv1vz7T0zT8huF51bAMVWriNvO1FMegHrQZNrtvRxbwf0fUPsFvwqR0U0fgiJNEA5Y30F2MoI2S7vv3EjVQ68C0cjw9frBoUE2Hj0BvFp9h3u6Vbsg4lc1C8AtHdaN8orKuNKkLRLuYEL52R1J3v8olJGZRLnRdVKIivixmX/eQpzgeExtp20jI1HxRP1AAZ6xZoILdqDPO549LO4WeG+685JRUTdiwcY5fjZlqeMxuT4PpMn1X9OWsS7NRj06Wa5E3Tvg4twjWp39KPfOdRte6P1T4JU=", "agentid": 218 }';
+#    ret,sMsg=wxcpt.DecryptMsg( sReqData, sReqMsgSig, sReqTimeStamp, sReqNonce)
+#    if( ret!=0 ):
+#       print "ERR: DecryptMsg ret: " + str(ret)
+#       sys.exit(1)
+#    else:
+#       print sMsg
+#    # 解密成功，sMsg即为json格式的明文
+#    # TODO: 对明文的处理
+#    # ...
+#    # ...
+
+#    print "=============================="
+   
+#    '''
+#    ------------使用示例三：企业回复用户消息的加密---------------
+#    企业被动回复用户的消息也需要进行加密，并且拼接成密文格式的json串。
+#    假设企业需要回复用户的明文如下：
+
+#     { 
+#             "ToUserName": "mycreate",
+#             "FromUserName":"wx5823bf96d3bd56c7",
+#             "CreateTime": 1348831860,
+#             "MsgType": "text",
+#             "Content": "this is a test",
+#             "MsgId": 1234567890123456,
+#             "AgentID": 128
+#     }
+
+#    为了将此段明文回复给用户，企业应： 1.自己生成时间时间戳(timestamp),随机数字串(nonce)以便生成消息体签名，也可以直接用从企业微信的post url上解析出的对应值。
+#    2.将明文加密得到密文。   3.用密文，步骤1生成的timestamp,nonce和企业在企业微信设定的token生成消息体签名。   4.将密文，消息体签名，时间戳，随机数字串拼接成json格式的字符串，发送给企业号。
+#    以上2，3，4步可以用企业微信提供的库函数EncryptMsg来实现。
+#    '''
+#    #sRespData = ' { "ToUserName": "mycreate", "FromUserName":"wx5823bf96d3bd56c7", "CreateTime": 1348831860, "MsgType": "text", "Content": "this is a test", "MsgId": 1234567890123456, "AgentID": 128 }';
+#    sRespData = '{ "ToUserName": "wx5823bf96d3bd56c7", "FromUserName": :mycreate", "CreateTime": 1409659813, "MsgType": "text", "Content": "hello", "MsgId": 4561255354251345929, "AgentID": 218}'
+#    ret,sEncryptMsg=wxcpt.EncryptMsg(sRespData, sReqNonce, sReqTimeStamp)
+#    if( ret!=0 ):
+#       print "ERR: EncryptMsg ret: " + str(ret)
+#       sys.exit(1)
+#    else:
+#       print sEncryptMsg
+#       #ret == 0 加密成功，企业需要将sEncryptMsg返回给企业号
+#    print "=============================="
```

## wework_callback_json/WXBizJsonMsgCrypt.py

 * *Ordering differences only*

```diff
@@ -1,279 +1,279 @@
-#!/usr/bin/env python
-#-*- encoding:utf-8 -*-
-
-""" 对企业微信发送给企业后台的消息加解密示例代码.
-@copyright: Copyright (c) 1998-2020 Tencent Inc.
-
-"""
-# ------------------------------------------------------------------------
-
-import base64
-import string
-import random
-import hashlib
-import time
-import struct
-from Crypto.Cipher import AES
-import sys
-import socket
-import json
-
-from . import ierror
-
-# import .ierror
-# reload(sys)
-# import ierror 
-# sys.setdefaultencoding('utf-8') 
-
-"""
-关于Crypto.Cipher模块，ImportError: No module named 'Crypto'解决方案
-请到官方网站 https://www.dlitz.net/software/pycrypto/ 下载pycrypto。
-下载后，按照README中的“Installation”小节的提示进行pycrypto安装。
-"""
-class FormatException(Exception):
-    pass
-
-def throw_exception(message, exception_class=FormatException):
-    """my define raise exception function"""
-    raise exception_class(message)
-
-class SHA1:
-    """计算企业微信的消息签名接口"""   
-    
-    def getSHA1(self, token, timestamp, nonce, encrypt):
-        """用SHA1算法生成安全签名
-        @param token:  票据
-        @param timestamp: 时间戳
-        @param encrypt: 密文
-        @param nonce: 随机字符串
-        @return: 安全签名
-        """
-        try:
-            sortlist = [token, timestamp, nonce, encrypt]
-            sortlist.sort()
-            sha = hashlib.sha1()
-            sha.update("".join(sortlist))
-            return  ierror.WXBizMsgCrypt_OK, sha.hexdigest()
-        except Exception as e:
-            # print e
-            return  ierror.WXBizMsgCrypt_ComputeSignature_Error, None
-  
-
-class JsonParse:
-    """提供提取消息格式中的密文及生成回复消息格式的接口"""   
-     
-    # json消息模板   
-    AES_TEXT_RESPONSE_TEMPLATE = '''{
-        "encrypt": "%(msg_encrypt)s",
-        "msgsignature": "%(msg_signaturet)s",
-        "timestamp": "%(timestamp)s",
-        "nonce": "%(nonce)s"
-    }'''
-
-    def extract(self, jsontext):
-        """提取出json数据包中的加密消息 
-        @param jsontext: 待提取的json字符串
-        @return: 提取出的加密消息字符串
-        """
-        try:
-            json_dict = json.loads(jsontext)
-            return  ierror.WXBizMsgCrypt_OK, json_dict['encrypt']
-        except Exception as e: 
-            # print e
-            return ierror.WXBizMsgCrypt_ParseJson_Error, None
-    def generate(self, encrypt, signature, timestamp, nonce):
-        """生成json消息
-        @param encrypt: 加密后的消息密文
-        @param signature: 安全签名
-        @param timestamp: 时间戳
-        @param nonce: 随机字符串
-        @return: 生成的json字符串
-        """
-        resp_dict = {
-                    'msg_encrypt' : encrypt,
-                    'msg_signaturet': signature,
-                    'timestamp'    : timestamp,
-                    'nonce'        : nonce,
-                     }
-        resp_json = self.AES_TEXT_RESPONSE_TEMPLATE % resp_dict
-        return resp_json   
-    
- 
-class PKCS7Encoder():
-    """提供基于PKCS7算法的加解密接口"""  
-    
-    block_size = 32
-    def encode(self, text):
-        """ 对需要加密的明文进行填充补位
-        @param text: 需要进行填充补位操作的明文
-        @return: 补齐明文字符串
-        """
-        text_length = len(text)
-        # 计算需要填充的位数
-        amount_to_pad = self.block_size - (text_length % self.block_size)
-        if amount_to_pad == 0:
-            amount_to_pad = self.block_size
-        # 获得补位所用的字符
-        pad = chr(amount_to_pad)
-        return text + pad * amount_to_pad
-    
-    def decode(self, decrypted):
-        """删除解密后明文的补位字符
-        @param decrypted: 解密后的明文
-        @return: 删除补位字符后的明文
-        """
-        pad = ord(decrypted[-1])
-        if pad<1 or pad >32:
-            pad = 0
-        return decrypted[:-pad]
-    
-    
-class Prpcrypt(object):
-    """提供接收和推送给企业微信消息的加解密接口"""
-    
-    def __init__(self,key):
-
-        #self.key = base64.b64decode(key+"=")
-        self.key = key
-        # 设置加解密模式为AES的CBC模式   
-        self.mode = AES.MODE_CBC
-    
-            
-    def encrypt(self,text,receiveid):
-        """对明文进行加密
-        @param text: 需要加密的明文
-        @return: 加密得到的字符串
-        """      
-        # 16位随机字符串添加到明文开头
-        text = self.get_random_str() + struct.pack("I",socket.htonl(len(text))) + text + receiveid
-        # 使用自定义的填充方式对明文进行补位填充
-        pkcs7 = PKCS7Encoder()
-        text = pkcs7.encode(text)
-        # 加密    
-        cryptor = AES.new(self.key,self.mode,self.key[:16])
-        try:
-            ciphertext = cryptor.encrypt(text)
-            # 使用BASE64对加密后的字符串进行编码
-            return ierror.WXBizMsgCrypt_OK, base64.b64encode(ciphertext)
-        except Exception as e:
-            # print e 
-            return  ierror.WXBizMsgCrypt_EncryptAES_Error,None
-    
-    def decrypt(self,text,receiveid):
-        """对解密后的明文进行补位删除
-        @param text: 密文 
-        @return: 删除填充补位后的明文
-        """
-        try:
-            cryptor = AES.new(self.key,self.mode,self.key[:16])
-            # 使用BASE64对密文进行解码，然后AES-CBC解密
-            plain_text  = cryptor.decrypt(base64.b64decode(text))
-        except Exception as e:
-            # print e 
-            return  ierror.WXBizMsgCrypt_DecryptAES_Error,None
-        try:
-            pad = ord(plain_text[-1]) 
-            # 去掉补位字符串 
-            #pkcs7 = PKCS7Encoder()
-            #plain_text = pkcs7.encode(plain_text)   
-            # 去除16位随机字符串
-            content = plain_text[16:-pad]
-            json_len = socket.ntohl(struct.unpack("I",content[ : 4])[0])
-            json_content = content[4 : json_len+4] 
-            from_receiveid = content[json_len+4:]
-        except Exception as e:
-            # print e
-            return  ierror.WXBizMsgCrypt_IllegalBuffer,None
-        if  from_receiveid != receiveid:
-            # print "receiveid not match"
-            # print from_receiveid 
-            return ierror.WXBizMsgCrypt_ValidateCorpid_Error,None
-        return 0, json_content
-    
-    def get_random_str(self):
-        """ 随机生成16位字符串
-        @return: 16位字符串
-        """ 
-        # rule = string.letters + string.digits
-        rule = string.ascii_letters + string.digits
-        str = random.sample(rule, 16)
-        return "".join(str)
-        
-class WXBizJsonMsgCrypt(object):
-    #构造函数
-    def __init__(self,sToken,sEncodingAESKey,sReceiveId):
-        try:
-            self.key = base64.b64decode(sEncodingAESKey+"=")  
-            assert len(self.key) == 32
-        except:
-            throw_exception("[error]: EncodingAESKey unvalid !", FormatException) 
-            # return ierror.WXBizMsgCrypt_IllegalAesKey,None
-        self.m_sToken = sToken
-        self.m_sReceiveId = sReceiveId
-
-		 #验证URL
-         #@param sMsgSignature: 签名串，对应URL参数的msg_signature
-         #@param sTimeStamp: 时间戳，对应URL参数的timestamp
-         #@param sNonce: 随机串，对应URL参数的nonce
-         #@param sEchoStr: 随机串，对应URL参数的echostr
-         #@param sReplyEchoStr: 解密之后的echostr，当return返回0时有效
-         #@return：成功0，失败返回对应的错误码	
-
-    def VerifyURL(self, sMsgSignature, sTimeStamp, sNonce, sEchoStr):
-        sha1 = SHA1()
-        ret,signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, sEchoStr)
-        if ret  != 0:
-            return ret, None 
-        if not signature == sMsgSignature:
-            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
-        pc = Prpcrypt(self.key)
-        ret,sReplyEchoStr = pc.decrypt(sEchoStr,self.m_sReceiveId)
-        return ret,sReplyEchoStr
-	
-    def EncryptMsg(self, sReplyMsg, sNonce, timestamp = None):
-        #将企业回复用户的消息加密打包
-        #@param sReplyMsg: 企业号待回复用户的消息，json格式的字符串
-        #@param sTimeStamp: 时间戳，可以自己生成，也可以用URL参数的timestamp,如为None则自动用当前时间
-        #@param sNonce: 随机串，可以自己生成，也可以用URL参数的nonce
-        #sEncryptMsg: 加密后的可以直接回复用户的密文，包括msg_signature, timestamp, nonce, encrypt的json格式的字符串,
-        #return：成功0，sEncryptMsg,失败返回对应的错误码None     
-        pc = Prpcrypt(self.key) 
-        ret,encrypt = pc.encrypt(sReplyMsg, self.m_sReceiveId)
-        if ret != 0:
-            return ret,None
-        if timestamp is None:
-            timestamp = str(int(time.time()))
-        # 生成安全签名 
-        sha1 = SHA1() 
-        ret,signature = sha1.getSHA1(self.m_sToken, timestamp, sNonce, encrypt)
-        if ret != 0: 
-            return ret,None 
-        jsonParse = JsonParse()  
-        return ret,jsonParse.generate(encrypt, signature, timestamp, sNonce)  
-
-    def DecryptMsg(self, sPostData, sMsgSignature, sTimeStamp, sNonce):
-        # 检验消息的真实性，并且获取解密后的明文
-        # @param sMsgSignature: 签名串，对应URL参数的msg_signature
-        # @param sTimeStamp: 时间戳，对应URL参数的timestamp
-        # @param sNonce: 随机串，对应URL参数的nonce
-        # @param sPostData: 密文，对应POST请求的数据
-        #  json_content: 解密后的原文，当return返回0时有效
-        # @return: 成功0，失败返回对应的错误码
-         # 验证安全签名 
-        jsonParse = JsonParse()
-        ret,encrypt = jsonParse.extract(sPostData)
-        if ret != 0:
-            return ret, None
-        sha1 = SHA1() 
-        ret,signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, encrypt)
-        if ret  != 0:
-            return ret, None 
-        if not signature == sMsgSignature:
-            # print "signature not match"
-            # print signature
-            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
-        pc = Prpcrypt(self.key)
-        ret,json_content = pc.decrypt(encrypt,self.m_sReceiveId)
-        return ret,json_content 
-
-
+#!/usr/bin/env python
+#-*- encoding:utf-8 -*-
+
+""" 对企业微信发送给企业后台的消息加解密示例代码.
+@copyright: Copyright (c) 1998-2020 Tencent Inc.
+
+"""
+# ------------------------------------------------------------------------
+
+import base64
+import string
+import random
+import hashlib
+import time
+import struct
+from Crypto.Cipher import AES
+import sys
+import socket
+import json
+
+from . import ierror
+
+# import .ierror
+# reload(sys)
+# import ierror 
+# sys.setdefaultencoding('utf-8') 
+
+"""
+关于Crypto.Cipher模块，ImportError: No module named 'Crypto'解决方案
+请到官方网站 https://www.dlitz.net/software/pycrypto/ 下载pycrypto。
+下载后，按照README中的“Installation”小节的提示进行pycrypto安装。
+"""
+class FormatException(Exception):
+    pass
+
+def throw_exception(message, exception_class=FormatException):
+    """my define raise exception function"""
+    raise exception_class(message)
+
+class SHA1:
+    """计算企业微信的消息签名接口"""   
+    
+    def getSHA1(self, token, timestamp, nonce, encrypt):
+        """用SHA1算法生成安全签名
+        @param token:  票据
+        @param timestamp: 时间戳
+        @param encrypt: 密文
+        @param nonce: 随机字符串
+        @return: 安全签名
+        """
+        try:
+            sortlist = [token, timestamp, nonce, encrypt]
+            sortlist.sort()
+            sha = hashlib.sha1()
+            sha.update("".join(sortlist))
+            return  ierror.WXBizMsgCrypt_OK, sha.hexdigest()
+        except Exception as e:
+            # print e
+            return  ierror.WXBizMsgCrypt_ComputeSignature_Error, None
+  
+
+class JsonParse:
+    """提供提取消息格式中的密文及生成回复消息格式的接口"""   
+     
+    # json消息模板   
+    AES_TEXT_RESPONSE_TEMPLATE = '''{
+        "encrypt": "%(msg_encrypt)s",
+        "msgsignature": "%(msg_signaturet)s",
+        "timestamp": "%(timestamp)s",
+        "nonce": "%(nonce)s"
+    }'''
+
+    def extract(self, jsontext):
+        """提取出json数据包中的加密消息 
+        @param jsontext: 待提取的json字符串
+        @return: 提取出的加密消息字符串
+        """
+        try:
+            json_dict = json.loads(jsontext)
+            return  ierror.WXBizMsgCrypt_OK, json_dict['encrypt']
+        except Exception as e: 
+            # print e
+            return ierror.WXBizMsgCrypt_ParseJson_Error, None
+    def generate(self, encrypt, signature, timestamp, nonce):
+        """生成json消息
+        @param encrypt: 加密后的消息密文
+        @param signature: 安全签名
+        @param timestamp: 时间戳
+        @param nonce: 随机字符串
+        @return: 生成的json字符串
+        """
+        resp_dict = {
+                    'msg_encrypt' : encrypt,
+                    'msg_signaturet': signature,
+                    'timestamp'    : timestamp,
+                    'nonce'        : nonce,
+                     }
+        resp_json = self.AES_TEXT_RESPONSE_TEMPLATE % resp_dict
+        return resp_json   
+    
+ 
+class PKCS7Encoder():
+    """提供基于PKCS7算法的加解密接口"""  
+    
+    block_size = 32
+    def encode(self, text):
+        """ 对需要加密的明文进行填充补位
+        @param text: 需要进行填充补位操作的明文
+        @return: 补齐明文字符串
+        """
+        text_length = len(text)
+        # 计算需要填充的位数
+        amount_to_pad = self.block_size - (text_length % self.block_size)
+        if amount_to_pad == 0:
+            amount_to_pad = self.block_size
+        # 获得补位所用的字符
+        pad = chr(amount_to_pad)
+        return text + pad * amount_to_pad
+    
+    def decode(self, decrypted):
+        """删除解密后明文的补位字符
+        @param decrypted: 解密后的明文
+        @return: 删除补位字符后的明文
+        """
+        pad = ord(decrypted[-1])
+        if pad<1 or pad >32:
+            pad = 0
+        return decrypted[:-pad]
+    
+    
+class Prpcrypt(object):
+    """提供接收和推送给企业微信消息的加解密接口"""
+    
+    def __init__(self,key):
+
+        #self.key = base64.b64decode(key+"=")
+        self.key = key
+        # 设置加解密模式为AES的CBC模式   
+        self.mode = AES.MODE_CBC
+    
+            
+    def encrypt(self,text,receiveid):
+        """对明文进行加密
+        @param text: 需要加密的明文
+        @return: 加密得到的字符串
+        """      
+        # 16位随机字符串添加到明文开头
+        text = self.get_random_str() + struct.pack("I",socket.htonl(len(text))) + text + receiveid
+        # 使用自定义的填充方式对明文进行补位填充
+        pkcs7 = PKCS7Encoder()
+        text = pkcs7.encode(text)
+        # 加密    
+        cryptor = AES.new(self.key,self.mode,self.key[:16])
+        try:
+            ciphertext = cryptor.encrypt(text)
+            # 使用BASE64对加密后的字符串进行编码
+            return ierror.WXBizMsgCrypt_OK, base64.b64encode(ciphertext)
+        except Exception as e:
+            # print e 
+            return  ierror.WXBizMsgCrypt_EncryptAES_Error,None
+    
+    def decrypt(self,text,receiveid):
+        """对解密后的明文进行补位删除
+        @param text: 密文 
+        @return: 删除填充补位后的明文
+        """
+        try:
+            cryptor = AES.new(self.key,self.mode,self.key[:16])
+            # 使用BASE64对密文进行解码，然后AES-CBC解密
+            plain_text  = cryptor.decrypt(base64.b64decode(text))
+        except Exception as e:
+            # print e 
+            return  ierror.WXBizMsgCrypt_DecryptAES_Error,None
+        try:
+            pad = ord(plain_text[-1]) 
+            # 去掉补位字符串 
+            #pkcs7 = PKCS7Encoder()
+            #plain_text = pkcs7.encode(plain_text)   
+            # 去除16位随机字符串
+            content = plain_text[16:-pad]
+            json_len = socket.ntohl(struct.unpack("I",content[ : 4])[0])
+            json_content = content[4 : json_len+4] 
+            from_receiveid = content[json_len+4:]
+        except Exception as e:
+            # print e
+            return  ierror.WXBizMsgCrypt_IllegalBuffer,None
+        if  from_receiveid != receiveid:
+            # print "receiveid not match"
+            # print from_receiveid 
+            return ierror.WXBizMsgCrypt_ValidateCorpid_Error,None
+        return 0, json_content
+    
+    def get_random_str(self):
+        """ 随机生成16位字符串
+        @return: 16位字符串
+        """ 
+        # rule = string.letters + string.digits
+        rule = string.ascii_letters + string.digits
+        str = random.sample(rule, 16)
+        return "".join(str)
+        
+class WXBizJsonMsgCrypt(object):
+    #构造函数
+    def __init__(self,sToken,sEncodingAESKey,sReceiveId):
+        try:
+            self.key = base64.b64decode(sEncodingAESKey+"=")  
+            assert len(self.key) == 32
+        except:
+            throw_exception("[error]: EncodingAESKey unvalid !", FormatException) 
+            # return ierror.WXBizMsgCrypt_IllegalAesKey,None
+        self.m_sToken = sToken
+        self.m_sReceiveId = sReceiveId
+
+		 #验证URL
+         #@param sMsgSignature: 签名串，对应URL参数的msg_signature
+         #@param sTimeStamp: 时间戳，对应URL参数的timestamp
+         #@param sNonce: 随机串，对应URL参数的nonce
+         #@param sEchoStr: 随机串，对应URL参数的echostr
+         #@param sReplyEchoStr: 解密之后的echostr，当return返回0时有效
+         #@return：成功0，失败返回对应的错误码	
+
+    def VerifyURL(self, sMsgSignature, sTimeStamp, sNonce, sEchoStr):
+        sha1 = SHA1()
+        ret,signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, sEchoStr)
+        if ret  != 0:
+            return ret, None 
+        if not signature == sMsgSignature:
+            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
+        pc = Prpcrypt(self.key)
+        ret,sReplyEchoStr = pc.decrypt(sEchoStr,self.m_sReceiveId)
+        return ret,sReplyEchoStr
+	
+    def EncryptMsg(self, sReplyMsg, sNonce, timestamp = None):
+        #将企业回复用户的消息加密打包
+        #@param sReplyMsg: 企业号待回复用户的消息，json格式的字符串
+        #@param sTimeStamp: 时间戳，可以自己生成，也可以用URL参数的timestamp,如为None则自动用当前时间
+        #@param sNonce: 随机串，可以自己生成，也可以用URL参数的nonce
+        #sEncryptMsg: 加密后的可以直接回复用户的密文，包括msg_signature, timestamp, nonce, encrypt的json格式的字符串,
+        #return：成功0，sEncryptMsg,失败返回对应的错误码None     
+        pc = Prpcrypt(self.key) 
+        ret,encrypt = pc.encrypt(sReplyMsg, self.m_sReceiveId)
+        if ret != 0:
+            return ret,None
+        if timestamp is None:
+            timestamp = str(int(time.time()))
+        # 生成安全签名 
+        sha1 = SHA1() 
+        ret,signature = sha1.getSHA1(self.m_sToken, timestamp, sNonce, encrypt)
+        if ret != 0: 
+            return ret,None 
+        jsonParse = JsonParse()  
+        return ret,jsonParse.generate(encrypt, signature, timestamp, sNonce)  
+
+    def DecryptMsg(self, sPostData, sMsgSignature, sTimeStamp, sNonce):
+        # 检验消息的真实性，并且获取解密后的明文
+        # @param sMsgSignature: 签名串，对应URL参数的msg_signature
+        # @param sTimeStamp: 时间戳，对应URL参数的timestamp
+        # @param sNonce: 随机串，对应URL参数的nonce
+        # @param sPostData: 密文，对应POST请求的数据
+        #  json_content: 解密后的原文，当return返回0时有效
+        # @return: 成功0，失败返回对应的错误码
+         # 验证安全签名 
+        jsonParse = JsonParse()
+        ret,encrypt = jsonParse.extract(sPostData)
+        if ret != 0:
+            return ret, None
+        sha1 = SHA1() 
+        ret,signature = sha1.getSHA1(self.m_sToken, sTimeStamp, sNonce, encrypt)
+        if ret  != 0:
+            return ret, None 
+        if not signature == sMsgSignature:
+            # print "signature not match"
+            # print signature
+            return ierror.WXBizMsgCrypt_ValidateSignature_Error, None
+        pc = Prpcrypt(self.key)
+        ret,json_content = pc.decrypt(encrypt,self.m_sReceiveId)
+        return ret,json_content 
+
+
```

## wework_callback_json/ierror.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#########################################################################
-# Author: jonyqin
-# Created Time: Thu 11 Sep 2014 01:53:58 PM CST
-# File Name: ierror.py
-# Description:定义错误码含义 
-#########################################################################
-WXBizMsgCrypt_OK = 0
-WXBizMsgCrypt_ValidateSignature_Error = -40001
-WXBizMsgCrypt_ParseJson_Error = -40002
-WXBizMsgCrypt_ComputeSignature_Error = -40003
-WXBizMsgCrypt_IllegalAesKey = -40004
-WXBizMsgCrypt_ValidateCorpid_Error = -40005
-WXBizMsgCrypt_EncryptAES_Error = -40006
-WXBizMsgCrypt_DecryptAES_Error = -40007
-WXBizMsgCrypt_IllegalBuffer = -40008
-WXBizMsgCrypt_EncodeBase64_Error = -40009
-WXBizMsgCrypt_DecodeBase64_Error = -40010
-WXBizMsgCrypt_GenReturnJson_Error = -40011
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#########################################################################
+# Author: jonyqin
+# Created Time: Thu 11 Sep 2014 01:53:58 PM CST
+# File Name: ierror.py
+# Description:定义错误码含义 
+#########################################################################
+WXBizMsgCrypt_OK = 0
+WXBizMsgCrypt_ValidateSignature_Error = -40001
+WXBizMsgCrypt_ParseJson_Error = -40002
+WXBizMsgCrypt_ComputeSignature_Error = -40003
+WXBizMsgCrypt_IllegalAesKey = -40004
+WXBizMsgCrypt_ValidateCorpid_Error = -40005
+WXBizMsgCrypt_EncryptAES_Error = -40006
+WXBizMsgCrypt_DecryptAES_Error = -40007
+WXBizMsgCrypt_IllegalBuffer = -40008
+WXBizMsgCrypt_EncodeBase64_Error = -40009
+WXBizMsgCrypt_DecodeBase64_Error = -40010
+WXBizMsgCrypt_GenReturnJson_Error = -40011
```

## wework_sendmsg/sendmsg.py

```diff
@@ -1,83 +1,98 @@
-import argparse
-import logging
-from itertools import chain
-import json
-import yaml
-from flatten_dict import unflatten
-from dict_recursive_update import recursive_update
-from weworkapi.CorpApi import CorpApi, CORP_API_TYPE
-
-
-def merge_message_argfields(message, fields):
-
-    # transform -a'touser=xxx agentid=xxx' to [touser=xxx, argentid=xxx]
-    fields = [ fld.split() for fld in fields]
-
-    # flatten the fields list,
-    # [[touser=xxx, agentid=xxx], msgtype=text] -> [touser=xxx, agentid=xxx, msgtype=text]
-    fields = list(chain(*fields))
-
-    # convert the k=v list to dict
-    flat_dict = dict([tuple(fld.split(sep='=', maxsplit=1)) for fld in fields])
-
-    # unflatten the dict
-    # ie. {'event.task_id': 'xxx'} -> {'event': {'task_id': xxx}}
-    unflat = unflatten(flat_dict, splitter='dot')
-
-    # recursive update the message dict with the unflatten arg fiedls
-    return recursive_update(message, unflat)
-
-
-def main():
-
-    parser = argparse.ArgumentParser()
-    parser.add_argument('-c', '--corpid', required=True, help='企业微信的企业ID')
-    parser.add_argument('-s', '--secret', required=True, help='企业微信内应用的Secret')
-    parser.add_argument('-t', '--token_cache', help='access_token的本地缓存文件')
-    parser.add_argument('-a', '--field', action='append',
-                        help='消息体字段，格式为K=V，添加或覆盖参数message中字段的值，例如 touser=xxx, interactive_taskcard.task_id=xxx')
-    parser.add_argument(
-        '-f', '--format', choices=['json', 'yaml'], default='json', help='参数message文本的格式')
-    parser.add_argument('-m', '--message', help='向企业微信应用发送的消息文本')
-    parser.add_argument('-l', '--level', choices=['DEBUG', 'INFO', 'WARNING',
-                        'ERROR', 'FATAL', 'CRITICAL'], default='INFO', help='logging level')
-
-    args = parser.parse_args()
-    logging.basicConfig(level=getattr(logging, args.level))
-    logging.debug(args)
-  
-    message = dict()
-    if args.format == 'json':
-        message = json.loads(args.message)
-    elif args.format == 'yaml':
-        message = yaml.safe_load(args.message)
-    message = merge_message_argfields(message, args.field)
-
-    token_cached = None
-
-    # Read access_token from cache file
-    if args.token_cache:
-        try:
-            with open(args.token_cache, mode='r', encoding='utf-8') as f:
-                token_cached = f.readline()
-        except Exception as e:
-            logging.warning(e)
-
-    # Send message using CorpApi
-    corpapi = CorpApi(args.corpid, args.secret)
-    corpapi.access_token = token_cached
-    corpapi.httpCall(CORP_API_TYPE['MESSAGE_SEND'], message)
-    logging.info(f'MESSAGE_SEND[{message}]')
-
-    # access_token changed, Write new access_token to cache file
-    if args.token_cache and token_cached != corpapi.access_token:
-        try:
-            with open(args.token_cache, mode='w', encoding='utf-8') as f:
-                f.write(corpapi.access_token)
-            logging.info(f'Update {args.token_cache} with new refresh token')
-        except Exception as e:
-            logging.error(e)
-
-
-if __name__ == '__main__':
-    main()
+import argparse
+import logging
+from itertools import chain
+import json
+import yaml
+from flatten_dict import unflatten
+from dict_recursive_update import recursive_update
+from weworkapi.CorpApi import CorpApi, CORP_API_TYPE
+
+
+def merge_message_argfields(message, fields):
+    # transform -a'touser=xxx agentid=xxx' to [touser=xxx, argentid=xxx]
+    fields = [fld.split() for fld in fields]
+
+    # flatten the fields list,
+    # [[touser=xxx, agentid=xxx], msgtype=text] -> [touser=xxx, agentid=xxx, msgtype=text]
+    fields = list(chain(*fields))
+
+    # convert the k=v list to dict
+    flat_dict = dict([tuple(fld.split(sep='=', maxsplit=1)) for fld in fields])
+
+    # unflatten the dict
+    # ie. {'event.task_id': 'xxx'} -> {'event': {'task_id': xxx}}
+    unflat = unflatten(flat_dict, splitter='dot')
+
+    # recursive update the message dict with the unflatten arg fiedls
+    return recursive_update(message, unflat)
+
+
+def sendmsg(args):
+    logging.basicConfig(level=getattr(logging, args.level))
+    logging.debug(args)
+
+    message = dict()
+    if args.format == 'json':
+        message = json.loads(args.message)
+    elif args.format == 'yaml':
+        message = yaml.safe_load(args.message)
+    message = merge_message_argfields(message, args.field)
+
+    token_cached = None
+
+    # Read access_token from cache file
+    if args.token_cache:
+        try:
+            with open(args.token_cache, mode='r', encoding='utf-8') as f:
+                token_cached = f.readline()
+        except Exception as e:
+            logging.warning(e)
+
+    # Send message using CorpApi
+    corpapi = CorpApi(args.corpid, args.secret)
+    corpapi.access_token = token_cached
+    corpapi.httpCall(CORP_API_TYPE['MESSAGE_SEND'], message)
+    logging.info(f'MESSAGE_SEND[{message}]')
+
+    # access_token changed, Write new access_token to cache file
+    if args.token_cache and token_cached != corpapi.access_token:
+        try:
+            with open(args.token_cache, mode='w', encoding='utf-8') as f:
+                f.write(corpapi.access_token)
+            logging.info(f'Update {args.token_cache} with new refresh token')
+        except Exception as e:
+            logging.error(e)
+
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument('-c', '--corpid', required=True, help='企业微信的企业ID')
+    parser.add_argument('-s', '--secret', required=True, help='企业微信内应用的Secret')
+    parser.add_argument('-t', '--token_cache', help='access_token的本地缓存文件')
+    parser.add_argument('-m', '--message', help='向企业微信应用发送的消息文本')
+    parser.add_argument(
+        '-a',
+        '--field',
+        action='append',
+        help='消息体字段，格式为K=V，添加或覆盖参数message中字段的值，'
+             '例如 touser=xxx, interactive_taskcard.task_id=xxx'
+    )
+    parser.add_argument(
+        '-f',
+        '--format',
+        choices=['json', 'yaml'],
+        default='json',
+        help='参数message文本的格式'
+    )
+    parser.add_argument(
+        '-l',
+        '--level',
+        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'FATAL', 'CRITICAL'],
+        default='INFO',
+        help='logging level'
+    )
+    sendmsg(args=parser.parse_args())
+
+
+if __name__ == '__main__':
+    main()
```

## weworkapi/AbstractApi.py

 * *Ordering differences only*

```diff
@@ -1,138 +1,138 @@
-#!/usr/bin/env python
-# -*- coding:utf-8 -*-
-##
- # Copyright (C) 2018 All rights reserved.
- #   
- # @File AbstractApi.py
- # @Brief 
- # @Author abelzhu, abelzhu@tencent.com
- # @Version 1.0
- # @Date 2018-02-24
- #
- #
- 
-# import sys
-# import os
-# import re
-
-import json
-import requests
-
-# sys.path.append("../../")
-
-# from conf import DEBUG
-
-class ApiException(Exception) :
-    def __init__(self, errCode, errMsg) :
-        self.errCode = errCode
-        self.errMsg = errMsg
-
-class AbstractApi(object) :
-    def __init__(self) : 
-        return
-
-    def getAccessToken(self) :
-        raise NotImplementedError
-    def refreshAccessToken(self) :
-        raise NotImplementedError
-
-    def getSuiteAccessToken(self) :
-        raise NotImplementedError
-    def refreshSuiteAccessToken(self) :
-        raise NotImplementedError
-
-    def getProviderAccessToken(self) :
-        raise NotImplementedError
-    def refreshProviderAccessToken(self) :
-        raise NotImplementedError
-
-    def httpCall(self, urlType, args=None) : 
-        shortUrl = urlType[0]
-        method = urlType[1]
-        response = {}
-        for retryCnt in range(0, 3) :
-            if 'POST' == method :
-                url = self.__makeUrl(shortUrl)
-                response = self.__httpPost(url, args)
-            elif 'GET' == method :
-                url = self.__makeUrl(shortUrl)
-                url = self.__appendArgs(url, args)
-                response = self.__httpGet(url)
-            else : 
-                raise ApiException(-1, "unknown method type")
-
-            # check if token expired
-            if self.__tokenExpired(response.get('errcode')) :
-                self.__refreshToken(shortUrl)
-                retryCnt += 1
-                continue
-            else :
-                break
-
-        return self.__checkResponse(response) 
-
-    @staticmethod
-    def __appendArgs(url, args) : 
-        if args is None :
-            return url
-
-        for key, value in args.items() : 
-            if '?' in url : 
-                url += ('&' + key + '=' + value)
-            else :
-                url += ('?' + key + '=' + value)
-        return url
-
-    @staticmethod
-    def __makeUrl(shortUrl) :
-        base = "https://qyapi.weixin.qq.com"
-        if shortUrl[0] == '/' :
-            return base + shortUrl
-        else :
-            return base + '/' + shortUrl 
-
-    def __appendToken(self, url) : 
-        if 'SUITE_ACCESS_TOKEN' in url :
-            return url.replace('SUITE_ACCESS_TOKEN', self.getSuiteAccessToken())
-        elif 'PROVIDER_ACCESS_TOKEN' in url :
-            return url.replace('PROVIDER_ACCESS_TOKEN', self.getProviderAccessToken())
-        elif 'ACCESS_TOKEN' in url :
-            return url.replace('ACCESS_TOKEN', self.getAccessToken())
-        else : 
-            return url
-
-    def __httpPost(self, url, args) :
-        realUrl = self.__appendToken(url)
-        return requests.post(realUrl, data = json.dumps(args, ensure_ascii = False).encode('utf-8')).json()
-
-    def __httpGet(self, url) :
-        realUrl = self.__appendToken(url)
-        return requests.get(realUrl).json()
-
-    def __post_file(self, url, media_file):
-        return requests.post(url, file=media_file).json()
-
-    @staticmethod
-    def __checkResponse(response):
-        errCode = response.get('errcode')
-        errMsg = response.get('errmsg')
-
-        if errCode is 0:
-            return response 
-        else:
-            raise ApiException(errCode, errMsg)
-
-    @staticmethod
-    def __tokenExpired(errCode) :
-        if errCode == 40014 or errCode == 42001 or errCode == 42007 or errCode == 42009 :
-            return True
-        else :
-            return False
-
-    def __refreshToken(self, url) :
-        if 'SUITE_ACCESS_TOKEN' in url :
-            self.refreshSuiteAccessToken()
-        elif 'PROVIDER_ACCESS_TOKEN' in url :
-            self.refreshProviderAccessToken()
-        elif 'ACCESS_TOKEN' in url :
-            self.refreshAccessToken()
+#!/usr/bin/env python
+# -*- coding:utf-8 -*-
+##
+ # Copyright (C) 2018 All rights reserved.
+ #   
+ # @File AbstractApi.py
+ # @Brief 
+ # @Author abelzhu, abelzhu@tencent.com
+ # @Version 1.0
+ # @Date 2018-02-24
+ #
+ #
+ 
+# import sys
+# import os
+# import re
+
+import json
+import requests
+
+# sys.path.append("../../")
+
+# from conf import DEBUG
+
+class ApiException(Exception) :
+    def __init__(self, errCode, errMsg) :
+        self.errCode = errCode
+        self.errMsg = errMsg
+
+class AbstractApi(object) :
+    def __init__(self) : 
+        return
+
+    def getAccessToken(self) :
+        raise NotImplementedError
+    def refreshAccessToken(self) :
+        raise NotImplementedError
+
+    def getSuiteAccessToken(self) :
+        raise NotImplementedError
+    def refreshSuiteAccessToken(self) :
+        raise NotImplementedError
+
+    def getProviderAccessToken(self) :
+        raise NotImplementedError
+    def refreshProviderAccessToken(self) :
+        raise NotImplementedError
+
+    def httpCall(self, urlType, args=None) : 
+        shortUrl = urlType[0]
+        method = urlType[1]
+        response = {}
+        for retryCnt in range(0, 3) :
+            if 'POST' == method :
+                url = self.__makeUrl(shortUrl)
+                response = self.__httpPost(url, args)
+            elif 'GET' == method :
+                url = self.__makeUrl(shortUrl)
+                url = self.__appendArgs(url, args)
+                response = self.__httpGet(url)
+            else : 
+                raise ApiException(-1, "unknown method type")
+
+            # check if token expired
+            if self.__tokenExpired(response.get('errcode')) :
+                self.__refreshToken(shortUrl)
+                retryCnt += 1
+                continue
+            else :
+                break
+
+        return self.__checkResponse(response) 
+
+    @staticmethod
+    def __appendArgs(url, args) : 
+        if args is None :
+            return url
+
+        for key, value in args.items() : 
+            if '?' in url : 
+                url += ('&' + key + '=' + value)
+            else :
+                url += ('?' + key + '=' + value)
+        return url
+
+    @staticmethod
+    def __makeUrl(shortUrl) :
+        base = "https://qyapi.weixin.qq.com"
+        if shortUrl[0] == '/' :
+            return base + shortUrl
+        else :
+            return base + '/' + shortUrl 
+
+    def __appendToken(self, url) : 
+        if 'SUITE_ACCESS_TOKEN' in url :
+            return url.replace('SUITE_ACCESS_TOKEN', self.getSuiteAccessToken())
+        elif 'PROVIDER_ACCESS_TOKEN' in url :
+            return url.replace('PROVIDER_ACCESS_TOKEN', self.getProviderAccessToken())
+        elif 'ACCESS_TOKEN' in url :
+            return url.replace('ACCESS_TOKEN', self.getAccessToken())
+        else : 
+            return url
+
+    def __httpPost(self, url, args) :
+        realUrl = self.__appendToken(url)
+        return requests.post(realUrl, data = json.dumps(args, ensure_ascii = False).encode('utf-8')).json()
+
+    def __httpGet(self, url) :
+        realUrl = self.__appendToken(url)
+        return requests.get(realUrl).json()
+
+    def __post_file(self, url, media_file):
+        return requests.post(url, file=media_file).json()
+
+    @staticmethod
+    def __checkResponse(response):
+        errCode = response.get('errcode')
+        errMsg = response.get('errmsg')
+
+        if errCode is 0:
+            return response 
+        else:
+            raise ApiException(errCode, errMsg)
+
+    @staticmethod
+    def __tokenExpired(errCode) :
+        if errCode == 40014 or errCode == 42001 or errCode == 42007 or errCode == 42009 :
+            return True
+        else :
+            return False
+
+    def __refreshToken(self, url) :
+        if 'SUITE_ACCESS_TOKEN' in url :
+            self.refreshSuiteAccessToken()
+        elif 'PROVIDER_ACCESS_TOKEN' in url :
+            self.refreshProviderAccessToken()
+        elif 'ACCESS_TOKEN' in url :
+            self.refreshAccessToken()
```

## weworkapi/CorpApi.py

 * *Ordering differences only*

```diff
@@ -1,104 +1,104 @@
-#!/usr/bin/env python
-# -*- coding:utf-8 -*-
-##
- # Copyright (C) 2018 All rights reserved.
- #
- # @File CorpApi.py
- # @Brief
- # @Author abelzhu, abelzhu@tencent.com
- # @Version 1.0
- # @Date 2018-02-24
- #
- #
-
-from .AbstractApi import AbstractApi
-
-CORP_API_TYPE = {
-        'GET_ACCESS_TOKEN' : ['/cgi-bin/gettoken', 'GET'],
-        'USER_CREATE' 	   : ['/cgi-bin/user/create?access_token=ACCESS_TOKEN', 'POST'],
-        'USER_GET' 	   : ['/cgi-bin/user/get?access_token=ACCESS_TOKEN', 'GET'],
-        'USER_UPDATE'      : ['/cgi-bin/user/update?access_token=ACCESS_TOKEN', 'POST'],
-        'USER_DELETE' 	   : ['/cgi-bin/user/delete?access_token=ACCESS_TOKEN', 'GET'],
-        'USER_BATCH_DELETE': ['/cgi-bin/user/batchdelete?access_token=ACCESS_TOKEN', 'POST'],
-        'USER_SIMPLE_LIST': ['/cgi-bin/user/simplelist?access_token=ACCESS_TOKEN', 'GET'],
-        'USER_LIST' 	   : ['/cgi-bin/user/list?access_token=ACCESS_TOKEN', 'GET'],
-        'USERID_TO_OPENID' : ['/cgi-bin/user/convert_to_openid?access_token=ACCESS_TOKEN', 'POST'],
-        'OPENID_TO_USERID' : ['/cgi-bin/user/convert_to_userid?access_token=ACCESS_TOKEN', 'POST'],
-        'USER_AUTH_SUCCESS': ['/cgi-bin/user/authsucc?access_token=ACCESS_TOKEN', 'GET'],
-
-        'DEPARTMENT_CREATE': ['/cgi-bin/department/create?access_token=ACCESS_TOKEN', 'POST'],
-        'DEPARTMENT_UPDATE': ['/cgi-bin/department/update?access_token=ACCESS_TOKEN', 'POST'],
-        'DEPARTMENT_DELETE': ['/cgi-bin/department/delete?access_token=ACCESS_TOKEN', 'GET'],
-        'DEPARTMENT_LIST'  : ['/cgi-bin/department/list?access_token=ACCESS_TOKEN', 'GET'],
-
-        'TAG_CREATE' 	   : ['/cgi-bin/tag/create?access_token=ACCESS_TOKEN', 'POST'],
-        'TAG_UPDATE' 	   : ['/cgi-bin/tag/update?access_token=ACCESS_TOKEN', 'POST'],
-        'TAG_DELETE'  	   : ['/cgi-bin/tag/delete?access_token=ACCESS_TOKEN', 'GET'],
-        'TAG_GET_USER' 	   : ['/cgi-bin/tag/get?access_token=ACCESS_TOKEN', 'GET'],
-        'TAG_ADD_USER' 	   : ['/cgi-bin/tag/addtagusers?access_token=ACCESS_TOKEN', 'POST'],
-        'TAG_DELETE_USER'  : ['/cgi-bin/tag/deltagusers?access_token=ACCESS_TOKEN', 'POST'],
-        'TAG_GET_LIST' 	   : ['/cgi-bin/tag/list?access_token=ACCESS_TOKEN', 'GET'],
-
-        'BATCH_JOB_GET_RESULT' : ['/cgi-bin/batch/getresult?access_token=ACCESS_TOKEN', 'GET'],
-
-        'BATCH_INVITE'     : ['/cgi-bin/batch/invite?access_token=ACCESS_TOKEN', 'POST'],
-
-        'AGENT_GET' 	   : ['/cgi-bin/agent/get?access_token=ACCESS_TOKEN', 'GET'],
-        'AGENT_SET' 	   : ['/cgi-bin/agent/set?access_token=ACCESS_TOKEN', 'POST'],
-        'AGENT_GET_LIST'   : ['/cgi-bin/agent/list?access_token=ACCESS_TOKEN', 'GET'],
-
-        'MENU_CREATE' : ['/cgi-bin/menu/create?access_token=ACCESS_TOKEN', 'POST'], ## TODO
-        'MENU_GET' 	   : ['/cgi-bin/menu/get?access_token=ACCESS_TOKEN', 'GET'],
-        'MENU_DELETE' 	   : ['/cgi-bin/menu/delete?access_token=ACCESS_TOKEN', 'GET'],
-
-        'MESSAGE_SEND' 	   : ['/cgi-bin/message/send?access_token=ACCESS_TOKEN', 'POST'],
-        'MESSAGE_REVOKE'   : ['/cgi-bin/message/revoke?access_token=ACCESS_TOKEN', 'POST'],
-
-        'MEDIA_GET' 	   : ['/cgi-bin/media/get?access_token=ACCESS_TOKEN', 'GET'],
-
-        'GET_USER_INFO_BY_CODE' : ['/cgi-bin/user/getuserinfo?access_token=ACCESS_TOKEN', 'GET'],
-        'GET_USER_DETAIL'  : ['/cgi-bin/user/getuserdetail?access_token=ACCESS_TOKEN', 'POST'],
-
-        'GET_TICKET' 	   : ['/cgi-bin/ticket/get?access_token=ACCESS_TOKEN', 'GET'],
-        'GET_JSAPI_TICKET' : ['/cgi-bin/get_jsapi_ticket?access_token=ACCESS_TOKEN', 'GET'],
-
-        'GET_CHECKIN_OPTION' : ['/cgi-bin/checkin/getcheckinoption?access_token=ACCESS_TOKEN', 'POST'],
-        'GET_CHECKIN_DATA' : ['/cgi-bin/checkin/getcheckindata?access_token=ACCESS_TOKEN', 'POST'],
-        'GET_APPROVAL_DATA': ['/cgi-bin/corp/getapprovaldata?access_token=ACCESS_TOKEN', 'POST'],
-
-        'GET_INVOICE_INFO' : ['/cgi-bin/card/invoice/reimburse/getinvoiceinfo?access_token=ACCESS_TOKEN', 'POST'],
-        'UPDATE_INVOICE_STATUS' :
-            ['/cgi-bin/card/invoice/reimburse/updateinvoicestatus?access_token=ACCESS_TOKEN', 'POST'],
-        'BATCH_UPDATE_INVOICE_STATUS' :
-            ['/cgi-bin/card/invoice/reimburse/updatestatusbatch?access_token=ACCESS_TOKEN', 'POST'],
-        'BATCH_GET_INVOICE_INFO' :
-            ['/cgi-bin/card/invoice/reimburse/getinvoiceinfobatch?access_token=ACCESS_TOKEN', 'POST'],
-
-        'APP_CHAT_CREATE'  : ['/cgi-bin/appchat/create?access_token=ACCESS_TOKEN', 'POST'],
-        'APP_CHAT_GET'     : ['/cgi-bin/appchat/get?access_token=ACCESS_TOKEN', 'GET'],
-        'APP_CHAT_UPDATE'  : ['/cgi-bin/appchat/update?access_token=ACCESS_TOKEN', 'POST'],
-        'APP_CHAT_SEND'    : ['/cgi-bin/appchat/send?access_token=ACCESS_TOKEN', 'POST'],
-
-        'MINIPROGRAM_CODE_TO_SESSION_KEY' : ['/cgi-bin/miniprogram/jscode2session?access_token=ACCESS_TOKEN', 'GET'],
-}
-
-class CorpApi(AbstractApi) :
-    def __init__(self, corpid, secret) :
-        self.corpid = corpid
-        self.secret = secret
-        self.access_token = None
-
-    def getAccessToken(self) :
-        if self.access_token is None :
-            self.refreshAccessToken()
-        return self.access_token
-
-    def refreshAccessToken(self) :
-        response = self.httpCall(
-                CORP_API_TYPE['GET_ACCESS_TOKEN'],
-                {
-                    'corpid'    :   self.corpid,
-                    'corpsecret':   self.secret,
-                })
-        self.access_token = response.get('access_token')
-
+#!/usr/bin/env python
+# -*- coding:utf-8 -*-
+##
+ # Copyright (C) 2018 All rights reserved.
+ #
+ # @File CorpApi.py
+ # @Brief
+ # @Author abelzhu, abelzhu@tencent.com
+ # @Version 1.0
+ # @Date 2018-02-24
+ #
+ #
+
+from .AbstractApi import AbstractApi
+
+CORP_API_TYPE = {
+        'GET_ACCESS_TOKEN' : ['/cgi-bin/gettoken', 'GET'],
+        'USER_CREATE' 	   : ['/cgi-bin/user/create?access_token=ACCESS_TOKEN', 'POST'],
+        'USER_GET' 	   : ['/cgi-bin/user/get?access_token=ACCESS_TOKEN', 'GET'],
+        'USER_UPDATE'      : ['/cgi-bin/user/update?access_token=ACCESS_TOKEN', 'POST'],
+        'USER_DELETE' 	   : ['/cgi-bin/user/delete?access_token=ACCESS_TOKEN', 'GET'],
+        'USER_BATCH_DELETE': ['/cgi-bin/user/batchdelete?access_token=ACCESS_TOKEN', 'POST'],
+        'USER_SIMPLE_LIST': ['/cgi-bin/user/simplelist?access_token=ACCESS_TOKEN', 'GET'],
+        'USER_LIST' 	   : ['/cgi-bin/user/list?access_token=ACCESS_TOKEN', 'GET'],
+        'USERID_TO_OPENID' : ['/cgi-bin/user/convert_to_openid?access_token=ACCESS_TOKEN', 'POST'],
+        'OPENID_TO_USERID' : ['/cgi-bin/user/convert_to_userid?access_token=ACCESS_TOKEN', 'POST'],
+        'USER_AUTH_SUCCESS': ['/cgi-bin/user/authsucc?access_token=ACCESS_TOKEN', 'GET'],
+
+        'DEPARTMENT_CREATE': ['/cgi-bin/department/create?access_token=ACCESS_TOKEN', 'POST'],
+        'DEPARTMENT_UPDATE': ['/cgi-bin/department/update?access_token=ACCESS_TOKEN', 'POST'],
+        'DEPARTMENT_DELETE': ['/cgi-bin/department/delete?access_token=ACCESS_TOKEN', 'GET'],
+        'DEPARTMENT_LIST'  : ['/cgi-bin/department/list?access_token=ACCESS_TOKEN', 'GET'],
+
+        'TAG_CREATE' 	   : ['/cgi-bin/tag/create?access_token=ACCESS_TOKEN', 'POST'],
+        'TAG_UPDATE' 	   : ['/cgi-bin/tag/update?access_token=ACCESS_TOKEN', 'POST'],
+        'TAG_DELETE'  	   : ['/cgi-bin/tag/delete?access_token=ACCESS_TOKEN', 'GET'],
+        'TAG_GET_USER' 	   : ['/cgi-bin/tag/get?access_token=ACCESS_TOKEN', 'GET'],
+        'TAG_ADD_USER' 	   : ['/cgi-bin/tag/addtagusers?access_token=ACCESS_TOKEN', 'POST'],
+        'TAG_DELETE_USER'  : ['/cgi-bin/tag/deltagusers?access_token=ACCESS_TOKEN', 'POST'],
+        'TAG_GET_LIST' 	   : ['/cgi-bin/tag/list?access_token=ACCESS_TOKEN', 'GET'],
+
+        'BATCH_JOB_GET_RESULT' : ['/cgi-bin/batch/getresult?access_token=ACCESS_TOKEN', 'GET'],
+
+        'BATCH_INVITE'     : ['/cgi-bin/batch/invite?access_token=ACCESS_TOKEN', 'POST'],
+
+        'AGENT_GET' 	   : ['/cgi-bin/agent/get?access_token=ACCESS_TOKEN', 'GET'],
+        'AGENT_SET' 	   : ['/cgi-bin/agent/set?access_token=ACCESS_TOKEN', 'POST'],
+        'AGENT_GET_LIST'   : ['/cgi-bin/agent/list?access_token=ACCESS_TOKEN', 'GET'],
+
+        'MENU_CREATE' : ['/cgi-bin/menu/create?access_token=ACCESS_TOKEN', 'POST'], ## TODO
+        'MENU_GET' 	   : ['/cgi-bin/menu/get?access_token=ACCESS_TOKEN', 'GET'],
+        'MENU_DELETE' 	   : ['/cgi-bin/menu/delete?access_token=ACCESS_TOKEN', 'GET'],
+
+        'MESSAGE_SEND' 	   : ['/cgi-bin/message/send?access_token=ACCESS_TOKEN', 'POST'],
+        'MESSAGE_REVOKE'   : ['/cgi-bin/message/revoke?access_token=ACCESS_TOKEN', 'POST'],
+
+        'MEDIA_GET' 	   : ['/cgi-bin/media/get?access_token=ACCESS_TOKEN', 'GET'],
+
+        'GET_USER_INFO_BY_CODE' : ['/cgi-bin/user/getuserinfo?access_token=ACCESS_TOKEN', 'GET'],
+        'GET_USER_DETAIL'  : ['/cgi-bin/user/getuserdetail?access_token=ACCESS_TOKEN', 'POST'],
+
+        'GET_TICKET' 	   : ['/cgi-bin/ticket/get?access_token=ACCESS_TOKEN', 'GET'],
+        'GET_JSAPI_TICKET' : ['/cgi-bin/get_jsapi_ticket?access_token=ACCESS_TOKEN', 'GET'],
+
+        'GET_CHECKIN_OPTION' : ['/cgi-bin/checkin/getcheckinoption?access_token=ACCESS_TOKEN', 'POST'],
+        'GET_CHECKIN_DATA' : ['/cgi-bin/checkin/getcheckindata?access_token=ACCESS_TOKEN', 'POST'],
+        'GET_APPROVAL_DATA': ['/cgi-bin/corp/getapprovaldata?access_token=ACCESS_TOKEN', 'POST'],
+
+        'GET_INVOICE_INFO' : ['/cgi-bin/card/invoice/reimburse/getinvoiceinfo?access_token=ACCESS_TOKEN', 'POST'],
+        'UPDATE_INVOICE_STATUS' :
+            ['/cgi-bin/card/invoice/reimburse/updateinvoicestatus?access_token=ACCESS_TOKEN', 'POST'],
+        'BATCH_UPDATE_INVOICE_STATUS' :
+            ['/cgi-bin/card/invoice/reimburse/updatestatusbatch?access_token=ACCESS_TOKEN', 'POST'],
+        'BATCH_GET_INVOICE_INFO' :
+            ['/cgi-bin/card/invoice/reimburse/getinvoiceinfobatch?access_token=ACCESS_TOKEN', 'POST'],
+
+        'APP_CHAT_CREATE'  : ['/cgi-bin/appchat/create?access_token=ACCESS_TOKEN', 'POST'],
+        'APP_CHAT_GET'     : ['/cgi-bin/appchat/get?access_token=ACCESS_TOKEN', 'GET'],
+        'APP_CHAT_UPDATE'  : ['/cgi-bin/appchat/update?access_token=ACCESS_TOKEN', 'POST'],
+        'APP_CHAT_SEND'    : ['/cgi-bin/appchat/send?access_token=ACCESS_TOKEN', 'POST'],
+
+        'MINIPROGRAM_CODE_TO_SESSION_KEY' : ['/cgi-bin/miniprogram/jscode2session?access_token=ACCESS_TOKEN', 'GET'],
+}
+
+class CorpApi(AbstractApi) :
+    def __init__(self, corpid, secret) :
+        self.corpid = corpid
+        self.secret = secret
+        self.access_token = None
+
+    def getAccessToken(self) :
+        if self.access_token is None :
+            self.refreshAccessToken()
+        return self.access_token
+
+    def refreshAccessToken(self) :
+        response = self.httpCall(
+                CORP_API_TYPE['GET_ACCESS_TOKEN'],
+                {
+                    'corpid'    :   self.corpid,
+                    'corpsecret':   self.secret,
+                })
+        self.access_token = response.get('access_token')
+
```

## weworkapi/ServiceCorpApi.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-#!/usr/bin/env python
-# -*- coding:utf-8 -*-
-##
- # Copyright (C) 2018 All rights reserved.
- #   
- # @File ServiceCorp.py
- # @Brief 
- # @Author abelzhu, abelzhu@tencent.com
- # @Version 1.0
- # @Date 2018-02-24
- #
- #
- 
-from .CorpApi import CorpApi
-
-SERVICE_CORP_API_TYPE = { 
-        'GET_CORP_TOKEN'    : ['/cgi-bin/service/get_corp_token?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'],
-        'GET_SUITE_TOKEN'   : ['/cgi-bin/service/get_suite_token', 'POST'], 
-        'GET_PRE_AUTH_CODE' : ['/cgi-bin/service/get_pre_auth_code?suite_access_token=SUITE_ACCESS_TOKEN', 'GET'],
-        'SET_SESSION_INFO'  : ['/cgi-bin/service/set_session_info?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'], 
-        'GET_PERMANENT_CODE': ['/cgi-bin/service/get_permanent_code?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'], 
-        'GET_AUTH_INFO'     : ['/cgi-bin/service/get_auth_info?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'], 
-        'GET_ADMIN_LIST'    : ['/cgi-bin/service/get_admin_list?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'],
-        'GET_USER_INFO_BY_3RD' : ['/cgi-bin/service/getuserinfo3rd?suite_access_token=SUITE_ACCESS_TOKEN', 'GET'],
-        'GET_USER_DETAIL_BY_3RD' : ['/cgi-bin/service/getuserdetail3rd?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'],
-}
-
-class ServiceCorpApi(CorpApi) :
-    def __init__(self, suite_id, suite_secret, suite_ticket, auth_corpid=None, permanent_code=None) :
-        self.suite_id = suite_id 
-        self.suite_secret = suite_secret
-        self.suite_ticket = suite_ticket
-
-        # 调用 CorpAPI 的function， 需要设置这两个参数
-        self.auth_corpid = auth_corpid 
-        self.permanent_code = permanent_code 
-
-        self.access_token = None
-        self.suite_access_token = None
-
-    ## override CorpApi 的 refreshAccessToken， 使用第三方服务商的方法
-    def getAccessToken(self) :
-        if self.access_token is None :
-            self.refreshAccessToken()
-        return self.access_token
-    def refreshAccessToken(self) :
-        response = self.httpCall(
-                SERVICE_CORP_API_TYPE['GET_CORP_TOKEN'],
-                {
-                    "auth_corpid"   : self.auth_corpid, 
-                    "permanent_code": self.permanent_code,
-                })
-        self.access_token = response.get('access_token') 
-
-    ##
-    def getSuiteAccessToken(self) :
-        if self.suite_access_token is None :
-            self.refreshSuiteAccessToken()
-        return self.suite_access_token
-
-    def refreshSuiteAccessToken(self) :
-        response = self.httpCall(
-                SERVICE_CORP_API_TYPE['GET_SUITE_TOKEN'],
-                {
-                    "suite_id"      : self.suite_id,
-                    "suite_secret"  : self.suite_secret,
-                    "suite_ticket"  : self.suite_ticket,
-                })
-        self.suite_access_token= response.get('suite_access_token') 
-
+#!/usr/bin/env python
+# -*- coding:utf-8 -*-
+##
+ # Copyright (C) 2018 All rights reserved.
+ #   
+ # @File ServiceCorp.py
+ # @Brief 
+ # @Author abelzhu, abelzhu@tencent.com
+ # @Version 1.0
+ # @Date 2018-02-24
+ #
+ #
+ 
+from .CorpApi import CorpApi
+
+SERVICE_CORP_API_TYPE = { 
+        'GET_CORP_TOKEN'    : ['/cgi-bin/service/get_corp_token?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'],
+        'GET_SUITE_TOKEN'   : ['/cgi-bin/service/get_suite_token', 'POST'], 
+        'GET_PRE_AUTH_CODE' : ['/cgi-bin/service/get_pre_auth_code?suite_access_token=SUITE_ACCESS_TOKEN', 'GET'],
+        'SET_SESSION_INFO'  : ['/cgi-bin/service/set_session_info?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'], 
+        'GET_PERMANENT_CODE': ['/cgi-bin/service/get_permanent_code?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'], 
+        'GET_AUTH_INFO'     : ['/cgi-bin/service/get_auth_info?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'], 
+        'GET_ADMIN_LIST'    : ['/cgi-bin/service/get_admin_list?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'],
+        'GET_USER_INFO_BY_3RD' : ['/cgi-bin/service/getuserinfo3rd?suite_access_token=SUITE_ACCESS_TOKEN', 'GET'],
+        'GET_USER_DETAIL_BY_3RD' : ['/cgi-bin/service/getuserdetail3rd?suite_access_token=SUITE_ACCESS_TOKEN', 'POST'],
+}
+
+class ServiceCorpApi(CorpApi) :
+    def __init__(self, suite_id, suite_secret, suite_ticket, auth_corpid=None, permanent_code=None) :
+        self.suite_id = suite_id 
+        self.suite_secret = suite_secret
+        self.suite_ticket = suite_ticket
+
+        # 调用 CorpAPI 的function， 需要设置这两个参数
+        self.auth_corpid = auth_corpid 
+        self.permanent_code = permanent_code 
+
+        self.access_token = None
+        self.suite_access_token = None
+
+    ## override CorpApi 的 refreshAccessToken， 使用第三方服务商的方法
+    def getAccessToken(self) :
+        if self.access_token is None :
+            self.refreshAccessToken()
+        return self.access_token
+    def refreshAccessToken(self) :
+        response = self.httpCall(
+                SERVICE_CORP_API_TYPE['GET_CORP_TOKEN'],
+                {
+                    "auth_corpid"   : self.auth_corpid, 
+                    "permanent_code": self.permanent_code,
+                })
+        self.access_token = response.get('access_token') 
+
+    ##
+    def getSuiteAccessToken(self) :
+        if self.suite_access_token is None :
+            self.refreshSuiteAccessToken()
+        return self.suite_access_token
+
+    def refreshSuiteAccessToken(self) :
+        response = self.httpCall(
+                SERVICE_CORP_API_TYPE['GET_SUITE_TOKEN'],
+                {
+                    "suite_id"      : self.suite_id,
+                    "suite_secret"  : self.suite_secret,
+                    "suite_ticket"  : self.suite_ticket,
+                })
+        self.suite_access_token= response.get('suite_access_token') 
+
```

## weworkapi/ServiceProviderApi.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-#!/usr/bin/env python
-# -*- coding:utf-8 -*-
-##
- # Copyright (C) 2018 All rights reserved.
- #   
- # @File ServiceProviderApi.py
- # @Brief 
- # @Author abelzhu, abelzhu@tencent.com
- # @Version 1.0
- # @Date 2018-02-26
- #
- #
- 
-from .AbstractApi import AbstractApi
-
-SERVICE_PROVIDER_API_TYPE = { 
-        'GET_PROVIDER_TOKEN': ['/cgi-bin/service/get_provider_token', 'POST'],
-        'GET_LOGIN_INFO'    : ['/cgi-bin/service/get_login_info?access_token=PROVIDER_ACCESS_TOKEN', 'POST'],
-        'GET_REGISTER_CODE' : ['/cgi-bin/service/get_register_code?provider_access_token=PROVIDER_ACCESS_TOKEN', 'POST'],
-        'GET_REGISTER_INFO' : ['/cgi-bin/service/get_register_info?provider_access_token=PROVIDER_ACCESS_TOKEN', 'POST'],
-        'SET_AGENT_SCOPE'   : ['/cgi-bin/agent/set_scope', 'POST'], ### TODO 
-        'SET_CONTACT_SYNC_SUCCESS' : ['/cgi-bin/sync/contact_sync_success', 'GET'],
-}
-
-class ServiceProviderApi(AbstractApi) :
-    def __init__(self, corpid, provider_secret) :
-        self.corpid = corpid
-        self.provider_secret = provider_secret 
-
-        self.provider_access_token = None
-
-    def getProviderAccessToken(self) :
-        if self.provider_access_token is None :
-            self.refreshProviderAccessToken()
-        return self.provider_access_token
-
-    def refreshProviderAccessToken(self) :
-        response = self.httpCall(
-                SERVICE_PROVIDER_API_TYPE['GET_PROVIDER_TOKEN'],
-                {
-                    'corpid'         :   self.corpid, 
-                    'provider_secret':   self.provider_secret, 
-                })
-        self.provider_access_token = response.get('provider_access_token') 
-
+#!/usr/bin/env python
+# -*- coding:utf-8 -*-
+##
+ # Copyright (C) 2018 All rights reserved.
+ #   
+ # @File ServiceProviderApi.py
+ # @Brief 
+ # @Author abelzhu, abelzhu@tencent.com
+ # @Version 1.0
+ # @Date 2018-02-26
+ #
+ #
+ 
+from .AbstractApi import AbstractApi
+
+SERVICE_PROVIDER_API_TYPE = { 
+        'GET_PROVIDER_TOKEN': ['/cgi-bin/service/get_provider_token', 'POST'],
+        'GET_LOGIN_INFO'    : ['/cgi-bin/service/get_login_info?access_token=PROVIDER_ACCESS_TOKEN', 'POST'],
+        'GET_REGISTER_CODE' : ['/cgi-bin/service/get_register_code?provider_access_token=PROVIDER_ACCESS_TOKEN', 'POST'],
+        'GET_REGISTER_INFO' : ['/cgi-bin/service/get_register_info?provider_access_token=PROVIDER_ACCESS_TOKEN', 'POST'],
+        'SET_AGENT_SCOPE'   : ['/cgi-bin/agent/set_scope', 'POST'], ### TODO 
+        'SET_CONTACT_SYNC_SUCCESS' : ['/cgi-bin/sync/contact_sync_success', 'GET'],
+}
+
+class ServiceProviderApi(AbstractApi) :
+    def __init__(self, corpid, provider_secret) :
+        self.corpid = corpid
+        self.provider_secret = provider_secret 
+
+        self.provider_access_token = None
+
+    def getProviderAccessToken(self) :
+        if self.provider_access_token is None :
+            self.refreshProviderAccessToken()
+        return self.provider_access_token
+
+    def refreshProviderAccessToken(self) :
+        response = self.httpCall(
+                SERVICE_PROVIDER_API_TYPE['GET_PROVIDER_TOKEN'],
+                {
+                    'corpid'         :   self.corpid, 
+                    'provider_secret':   self.provider_secret, 
+                })
+        self.provider_access_token = response.get('provider_access_token') 
+
```

## Comparing `weworkapi_cfomp-1.1.4.dist-info/METADATA` & `EGG-INFO/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,24 +1,19 @@
-Metadata-Version: 2.1
-Name: weworkapi-cfomp
-Version: 1.1.4
-Summary: wework server side api
-Home-page: UNKNOWN
-Author: chenhp
-Author-email: chenhp@shchinafortune.com
-License: UNKNOWN
-Platform: UNKNOWN
-Requires-Dist: requests
-Requires-Dist: pycryptodome
-Requires-Dist: PyYAML
-Requires-Dist: flatten-dict
-Requires-Dist: dict-recursive-update
-
-# 简介
-  企业微信服务端API，运管平台依据 https://github.com/sbzhu/weworkapi_python.git 改写成python3版本
-  企业微信服务端API文档地址 https://work.weixin.qq.com/api/doc/90000/90135/90664
-
-
-  运管平台目前和企业微信的集成主机在以下两个应用场景：
-  1. 发送应用消息， https://work.weixin.qq.com/api/doc/90000/90135/90236
-  2. 接收消息与事件， https://work.weixin.qq.com/api/doc/90000/90135/90237
-
+Metadata-Version: 2.1
+Name: weworkapi-cfomp
+Version: 1.1.5.dev0
+Summary: wework server side api
+Home-page: UNKNOWN
+Author: chenhp
+Author-email: chenhp@shchinafortune.com
+License: UNKNOWN
+Platform: UNKNOWN
+
+# 简介
+  企业微信服务端API，运管平台依据 https://github.com/sbzhu/weworkapi_python.git 改写成python3版本
+  企业微信服务端API文档地址 https://work.weixin.qq.com/api/doc/90000/90135/90664
+
+
+  运管平台目前和企业微信的集成主机在以下两个应用场景：
+  1. 发送应用消息， https://work.weixin.qq.com/api/doc/90000/90135/90236
+  2. 接收消息与事件， https://work.weixin.qq.com/api/doc/90000/90135/90237
+
```

